<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Howl&#39;s</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://blog.xiaoquankong.ai/"/>
  <updated>2018-08-14T04:16:13.247Z</updated>
  <id>https://blog.xiaoquankong.ai/</id>
  
  <author>
    <name>Xiaoquan Kong</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>构建中文分词器 - 双向最大匹配法</title>
    <link href="https://blog.xiaoquankong.ai/%E6%9E%84%E5%BB%BA%E4%B8%AD%E6%96%87%E5%88%86%E8%AF%8D%E5%99%A8-%E5%8F%8C%E5%90%91%E6%9C%80%E5%A4%A7%E5%8C%B9%E9%85%8D%E6%B3%95/"/>
    <id>https://blog.xiaoquankong.ai/构建中文分词器-双向最大匹配法/</id>
    <published>2018-08-14T03:41:17.000Z</published>
    <updated>2018-08-14T04:16:13.247Z</updated>
    
    <content type="html"><![CDATA[<p>结合 <code>正向最大匹配法</code> 和 <code>反向最大匹配法</code> 的优点，按照一定的规则选择其中表现最优秀的结果作为 <code>双向最大匹配法</code> 的结果。<br><a id="more"></a></p><h1 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h1><p>从 <code>正向最大匹配法</code> 和 <code>反向最大匹配法</code> 的结果中选择最满足中文分词原则的一个分词结果。</p><h2 id="中文分词原则"><a href="#中文分词原则" class="headerlink" title="中文分词原则"></a>中文分词原则</h2><h3 id="分词粒度以大为最佳（最大化平均词语长度）"><a href="#分词粒度以大为最佳（最大化平均词语长度）" class="headerlink" title="分词粒度以大为最佳（最大化平均词语长度）"></a>分词粒度以大为最佳（最大化平均词语长度）</h3><p>分词的结果颗粒度（单个词所包含的字符长度）越大越好。</p><p>同样是 <code>北京大学</code> 可以分成 <code>北京</code> / <code>大学</code> 或者 <code>北京大学</code>，则后者更优，后者包含的信息更加特定和明确。</p><h3 id="非词典词越少越佳，单字字典词数越少越佳"><a href="#非词典词越少越佳，单字字典词数越少越佳" class="headerlink" title="非词典词越少越佳，单字字典词数越少越佳"></a>非词典词越少越佳，单字字典词数越少越佳</h3><p>非词典词的出现说明出现了 OOV (Out Of Vocabulary) 问题，字典足够大的情况下出现 OOV， 说明分词结果不佳。类似的，分词结果大量出现单个字，也是暗示分词效果不佳。</p><p>比如 <code>技术和服务</code> 可以被分成 <code>技术</code> / <code>和</code> / <code>服务</code> 或者 <code>技术</code> / <code>和服</code> / <code>务</code>，后者中的 <code>务</code> 就是一个 OOV，因为中文中 <code>务</code> 不能单独成词</p><h3 id="最小化词语长度的变化率"><a href="#最小化词语长度的变化率" class="headerlink" title="最小化词语长度的变化率"></a>最小化词语长度的变化率</h3><p>同样是 <code>研究生命起源</code> 可以被分成 <code>研究生</code> / <code>命</code> / <code>起源</code> 和 <code>研究</code> / <code>生命</code> / <code>起源</code>，后者 词语长度的变化率 最小，因此是更好的分词结果。</p><h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><p>通过分别实现 <code>正向最大匹配法</code> 和 <code>反向最大匹配法</code> 按照上述原则实现一个判别器，判别最优结果，返回即可。</p><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><ul><li><a href="http://www.360doc.com/content/14/0716/10/18582958_394733004.shtml" target="_blank" rel="noopener">关于MMSEG分词算法</a></li><li><a href="https://blog.csdn.net/jusang486/article/details/37561365" target="_blank" rel="noopener">中文分词基础原则及正向最大匹配法、逆向最大匹配法、双向最大匹配法的分析</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;结合 &lt;code&gt;正向最大匹配法&lt;/code&gt; 和 &lt;code&gt;反向最大匹配法&lt;/code&gt; 的优点，按照一定的规则选择其中表现最优秀的结果作为 &lt;code&gt;双向最大匹配法&lt;/code&gt; 的结果。&lt;br&gt;
    
    </summary>
    
    
      <category term="中文分词器" scheme="https://blog.xiaoquankong.ai/tags/%E4%B8%AD%E6%96%87%E5%88%86%E8%AF%8D%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>构建中文分词器-反向最大匹配法</title>
    <link href="https://blog.xiaoquankong.ai/%E6%9E%84%E5%BB%BA%E4%B8%AD%E6%96%87%E5%88%86%E8%AF%8D%E5%99%A8-%E5%8F%8D%E5%90%91%E6%9C%80%E5%A4%A7%E5%8C%B9%E9%85%8D%E6%B3%95/"/>
    <id>https://blog.xiaoquankong.ai/构建中文分词器-反向最大匹配法/</id>
    <published>2018-08-13T13:47:42.666Z</published>
    <updated>2018-08-14T04:18:19.960Z</updated>
    
    <content type="html"><![CDATA[<p>最大匹配每次寻找和确定最佳分词的时候按照最长（最大）匹配作为依据，从字符串的右边到左边（反向）依次寻找最大匹配。<br><a id="more"></a></p><h1 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h1><p>从解释的角度，可以理解为：判断待分词字符串的后 N 个字符构成的字符串是否在字典中，如果在，则匹配结束。如果没有匹配成功，则依次缩减 N 直到匹配成功。</p><h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><p>以 <code>中国的首都是北京</code> 为例, 假设 N 初始化为 4：</p><ol><li>匹配 <code>都是北京</code>， 字典中无此词语，匹配失败，缩减 N 为 3</li><li>匹配 <code>是北京</code>， 字典中无此词语，匹配失败，缩减 N 为 2</li><li>匹配 <code>北京</code>， 字典中有此词语，匹配成功，结束匹配</li></ol><p>继续匹配剩余未分词字符串 <code>中国的首都是</code>，直至字符串全部被分词。</p><h1 id="局限"><a href="#局限" class="headerlink" title="局限"></a>局限</h1><p>因为只考虑了能否构成词汇，完全没有考虑上下文，所以部分情况下会出现问题。<br>例如 <code>中国的首都是北京</code> 则会被分成 <code>中国</code> / <code>的</code> / <code>首</code> / <code>都是</code> / <code>北京</code></p><h1 id="优化方案"><a href="#优化方案" class="headerlink" title="优化方案"></a>优化方案</h1><p>本算法耗时最大的部分在于扫描词典，因此可以通过特定的数据结构优化加速字典查找过程：</p><ol><li>按照长度分别构建多个字典，能够一定程度的加速字典扫描的速度</li><li>使用 Trie-Tree 能够极大的加速查找过程</li></ol><h1 id="关联算法"><a href="#关联算法" class="headerlink" title="关联算法"></a>关联算法</h1><p>和 <code>最大正向匹配法</code> 思想完全一样，用于解决 <code>最大正向匹配法</code> 的某些问题。比如：<code>我们在野生动物园玩</code> 在 <code>最大正向匹配法</code> 中无法正确分词，但 <code>反向最大匹配法</code> 能够正确分词。</p><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><ul><li><a href="https://blog.csdn.net/jusang486/article/details/37561365" target="_blank" rel="noopener">中文分词基础原则及正向最大匹配法、逆向最大匹配法、双向最大匹配法的分析</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最大匹配每次寻找和确定最佳分词的时候按照最长（最大）匹配作为依据，从字符串的右边到左边（反向）依次寻找最大匹配。&lt;br&gt;
    
    </summary>
    
    
      <category term="中文分词器" scheme="https://blog.xiaoquankong.ai/tags/%E4%B8%AD%E6%96%87%E5%88%86%E8%AF%8D%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>构建中文分词器 - 正向最大匹配法</title>
    <link href="https://blog.xiaoquankong.ai/%E6%9E%84%E5%BB%BA%E4%B8%AD%E6%96%87%E5%88%86%E8%AF%8D%E5%99%A8-%E6%AD%A3%E5%90%91%E6%9C%80%E5%A4%A7%E5%8C%B9%E9%85%8D%E6%B3%95/"/>
    <id>https://blog.xiaoquankong.ai/构建中文分词器-正向最大匹配法/</id>
    <published>2018-08-13T13:00:49.888Z</published>
    <updated>2018-08-14T04:16:38.928Z</updated>
    
    <content type="html"><![CDATA[<p>最大匹配每次寻找和确定最佳分词的时候按照最长（最大）匹配作为依据，从字符串的左边到右边（正向）依次寻找最大匹配。<br><a id="more"></a></p><h1 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h1><p>从解释的角度，可以理解为：判断待分词字符串的前 N 个字符构成的字符串是否在字典中，如果在，则匹配结束。如果没有匹配成功，则依次缩减 N 直到匹配成功。</p><h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><p>以 <code>我们在野生动物园玩</code> 为例, 假设 N 初始化为 4：</p><ol><li>匹配 <code>我们在野</code>， 字典中无此词语，匹配失败，缩减 N 为 3</li><li>匹配 <code>我们在</code>， 字典中无此词语，匹配失败，缩减 N 为 2</li><li>匹配 <code>我们</code>， 字典中有此词语，匹配成功，结束匹配</li></ol><p>继续匹配剩余未分词字符串 <code>在野生动物园玩</code>，直至字符串全部被分词。</p><h1 id="局限"><a href="#局限" class="headerlink" title="局限"></a>局限</h1><p>因为只考虑了能否构成词汇，完全没有考虑上下文，所以部分情况下会出现问题。<br>例如 <code>我们在野生动物园玩</code> 则会被分成 <code>我们</code> / <code>在野</code> / <code>生动</code> / <code>物</code> / <code>园</code> / <code>玩</code></p><h1 id="优化方案"><a href="#优化方案" class="headerlink" title="优化方案"></a>优化方案</h1><p>本算法耗时最大的部分在于扫描词典，因此可以通过特定的数据结构优化加速字典查找过程：</p><ol><li>按照长度分别构建多个字典，能够一定程度的加速字典扫描的速度</li><li>使用 Trie-Tree 能够极大的加速查找过程</li></ol><h1 id="关联算法"><a href="#关联算法" class="headerlink" title="关联算法"></a>关联算法</h1><p><code>反向最大匹配法</code> 和 <code>最大正向匹配法</code> 思想完全一样，用于解决 <code>最大正向匹配法</code> 的某些问题。比如：<code>我们在野生动物园玩</code> 在 <code>最大正向匹配法</code> 中无法正确分词，但 <code>反向最大匹配法</code> 能够正确分词。</p><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><ul><li><a href="https://blog.csdn.net/jusang486/article/details/37561365" target="_blank" rel="noopener">中文分词基础原则及正向最大匹配法、逆向最大匹配法、双向最大匹配法的分析</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最大匹配每次寻找和确定最佳分词的时候按照最长（最大）匹配作为依据，从字符串的左边到右边（正向）依次寻找最大匹配。&lt;br&gt;
    
    </summary>
    
    
      <category term="中文分词器" scheme="https://blog.xiaoquankong.ai/tags/%E4%B8%AD%E6%96%87%E5%88%86%E8%AF%8D%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>基于 OpenAI Gym 的 Q-Learning 算法演示</title>
    <link href="https://blog.xiaoquankong.ai/%E5%9F%BA%E4%BA%8E-OpenAI-Gym-%E7%9A%84-Q-Learning-%E7%AE%97%E6%B3%95%E6%BC%94%E7%A4%BA/"/>
    <id>https://blog.xiaoquankong.ai/基于-OpenAI-Gym-的-Q-Learning-算法演示/</id>
    <published>2018-08-13T11:08:02.499Z</published>
    <updated>2018-08-13T11:08:02.499Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://mybinder.org/v2/gh/howl-anderson/q_learning_demo/master?filepath=jupyter_notebooks%2Fproof-of-concept.ipynb" target="_blank" rel="noopener"><img src="https://mybinder.org/badge.svg" alt="Binder"></a></p><p><strong>TL;DR</strong> 从零开始实现 Q-learning 算法，在 OpenAI Gym 的环境中演示：如何一步步实现增强学习。</p><a id="more"></a><p>前面的博文里已经介绍过 Q-learning 的一些基本情况了，如果你没见过前面的博文或者已经忘记的差不多了，那么可以使用这个 <a href="/Reinforcement-Learning-初次交手，多多指教/">Reinforcement Learning: 初次交手，多多指教</a> 访问。</p><p>但是总的来说，如果没有实际代码跑一番，估计你对这个算法的正确性还是有疑虑的。本文将从头构建一个 Q-learning 算法，来解决一个 toy 级别的强化学习场景的学习工作。希望能加深你对 Q-learning 的理解和对强化学习的认知。</p><h3 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h3><ul><li>比较精美的，但是做了一定扩展的实现在 <a href="https://github.com/howl-anderson/q_learning_demo" target="_blank" rel="noopener">q_learning_demo</a></li><li>和本文代码相对应的，稍有改动的 Jupyter Notebook 在  <a href="https://mybinder.org/v2/gh/howl-anderson/q_learning_demo/master?filepath=jupyter_notebooks%2Fproof-of-concept.ipynb" target="_blank" rel="noopener">proof-of-concept</a></li></ul><h3 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h3><p>我们要用 Q-learning 解决什么问题呢？我们使用 OpenAI Gym 里提供的一个环境：<code>FrozenLake-v0</code>.</p><p><code>FrozenLake-v0</code> 环境的中文描述大概是这样的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">冬天的时候，你和你的朋友们在公园扔飞盘。</span><br><span class="line">你不小心把飞盘扔到了公园的湖中间。</span><br><span class="line">湖面已经结冰，但是有些地方的没有结冰，形成一个冰洞，有人踩上去会掉下去。</span><br><span class="line">这个飞盘对你来说非常宝贵，你觉得非常有必要把飞盘拿回来。</span><br><span class="line">但是冰面很滑，你不能总是想去什么方向就去什么方向，滑滑的冰面可能会带你走向别的方向。</span><br><span class="line">冰面用如下的字符块表示：</span><br><span class="line">    SFFF</span><br><span class="line">    FHFH</span><br><span class="line">    FFFH</span><br><span class="line">    HFFG</span><br><span class="line">S : Safe，开始点，安全</span><br><span class="line">F : frozen surface, 冻结的表面，安全</span><br><span class="line">H : hole, 掉下去就死定了</span><br><span class="line">G : goal, 飞盘所在的地方</span><br><span class="line"></span><br><span class="line">每个轮回，以你拿回飞盘或者掉进洞里而结束。</span><br><span class="line">只有当你拿到飞盘才能获得1个奖励，其他情况都为0</span><br></pre></td></tr></table></figure><h3 id="OpenAI-Gym"><a href="#OpenAI-Gym" class="headerlink" title="OpenAI Gym"></a>OpenAI Gym</h3><p>OpenAI 是 Elon Musk 创建的一家致力于非盈利的通用人工智能的公司。 其开源产品 <code>Gym</code> 是提供了一种增强学习的实现框架，主要用于提供一些模拟器供研究使用。</p><p>之前的博客提到过，增强学习是 Agent 和 Environment 直接的交互构成的。Gym 提供了很多常见的 Environment 对象。利用这些 Environment，研究者可以很快构建增强学习的应用。</p><h3 id="Gym-运行模式"><a href="#Gym-运行模式" class="headerlink" title="Gym 运行模式"></a>Gym 运行模式</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 导入gym</span></span><br><span class="line"><span class="keyword">import</span> gym</span><br><span class="line"></span><br><span class="line"><span class="comment"># 构建环境</span></span><br><span class="line">env = gym.make(<span class="string">"Taxi-v1"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取第一次的观察结果</span></span><br><span class="line">observation = env.reset()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 开始探索环境</span></span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">1000</span>):</span><br><span class="line">    env.render()  <span class="comment"># 渲染观察结果</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 你的 Agent 应该会根据观察结果，选择最合适的动作，但这里我们使用随机选择的动作</span></span><br><span class="line">    action = env.action_space.sample() <span class="comment"># your agent here (this takes random actions)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 将动作发送给环境，获取新的观察结果、奖励和是否结束的标志等</span></span><br><span class="line">    observation, reward, done, info = env.step(action)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> done:  <span class="comment"># 游戏结束</span></span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure><p>通过上面的示例，你应该了解OpenAI gym的工作模式。</p><h3 id="训练流程"><a href="#训练流程" class="headerlink" title="训练流程"></a>训练流程</h3><p>导入依赖<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> gym</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line"><span class="keyword">import</span> functools</span><br></pre></td></tr></table></figure></p><p>定义两个主要组件<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 构建 Environment</span></span><br><span class="line">env = gym.make(<span class="string">'FrozenLake-v0'</span>)</span><br><span class="line">env.seed(<span class="number">0</span>)  <span class="comment"># 确保结果具有可重现性</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 构建 Agent</span></span><br><span class="line">tabular_q_agent = TabularQAgent(env.observation_space, env.action_space)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 开始训练</span></span><br><span class="line">train(tabular_q_agent, env)</span><br><span class="line"></span><br><span class="line">tabular_q_agent.test(env)</span><br></pre></td></tr></table></figure></p><p>训练循环<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">train</span><span class="params">(tabular_q_agent, env)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> episode <span class="keyword">in</span> range(<span class="number">100000</span>):  <span class="comment"># 训练 100000 次</span></span><br><span class="line">        all_reward, step_count = tabular_q_agent.learn(env)</span><br></pre></td></tr></table></figure></p><p>TabularQAgent 的实现</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TabularQAgent</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, observation_space, action_space)</span>:</span></span><br><span class="line">        self.observation_space = observation_space</span><br><span class="line">        self.action_space = action_space</span><br><span class="line">        self.action_n = action_space.n</span><br><span class="line">        self.config = &#123;</span><br><span class="line">            <span class="string">"learning_rate"</span>: <span class="number">0.5</span>,</span><br><span class="line">            <span class="string">"eps"</span>: <span class="number">0.05</span>,            <span class="comment"># Epsilon in epsilon greedy policies</span></span><br><span class="line">            <span class="string">"discount"</span>: <span class="number">0.99</span>,</span><br><span class="line">            <span class="string">"n_iter"</span>: <span class="number">10000</span>&#125;        <span class="comment"># Number of iterations</span></span><br><span class="line"></span><br><span class="line">        self.q = defaultdict(functools.partial(generate_zeros, n=self.action_n))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">act</span><span class="params">(self, observation, eps=None)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> eps <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">            eps = self.config[<span class="string">"eps"</span>]      </span><br><span class="line">        <span class="comment"># epsilon greedy.</span></span><br><span class="line">        action = np.argmax(self.q[observation]) <span class="keyword">if</span> np.random.random() &gt; eps <span class="keyword">else</span> self.action_space.sample()</span><br><span class="line">        <span class="keyword">return</span> action</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">learn</span><span class="params">(self, env)</span>:</span></span><br><span class="line">        obs = env.reset()</span><br><span class="line"></span><br><span class="line">        rAll = <span class="number">0</span></span><br><span class="line">        step_count = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> t <span class="keyword">in</span> range(self.config[<span class="string">"n_iter"</span>]):</span><br><span class="line">            action = self.act(obs)</span><br><span class="line">            obs2, reward, done, _ = env.step(action)</span><br><span class="line"></span><br><span class="line">            future = <span class="number">0.0</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> done:</span><br><span class="line">                future = np.max(self.q[obs2])</span><br><span class="line">            self.q[obs][action] = (<span class="number">1</span> - self.config[<span class="string">"learning_rate"</span>]) * self.q[obs][action] + self.config[<span class="string">"learning_rate"</span>] * (reward + self.config[<span class="string">"discount"</span>] * future)</span><br><span class="line"></span><br><span class="line">            obs = obs2</span><br><span class="line"></span><br><span class="line">            rAll += reward</span><br><span class="line">            step_count += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> done:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> rAll, step_count</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">(self, env)</span>:</span></span><br><span class="line">        obs = env.reset()</span><br><span class="line">        env.render(mode=<span class="string">'human'</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> t <span class="keyword">in</span> range(self.config[<span class="string">"n_iter"</span>]):</span><br><span class="line">            env.render(mode=<span class="string">'human'</span>)</span><br><span class="line"></span><br><span class="line">            action = self.act(obs, eps=<span class="number">0</span>)</span><br><span class="line">            obs2, reward, done, _ = env.step(action)</span><br><span class="line">            env.render(mode=<span class="string">'human'</span>)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> done:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">            obs = obs2</span><br></pre></td></tr></table></figure><h3 id="核心代码"><a href="#核心代码" class="headerlink" title="核心代码"></a>核心代码</h3><p>我们重点关注核心代码，Q-learning 是如何学习的，相关代码简化后得到：</p><h4 id="如何更新-Q-table"><a href="#如何更新-Q-table" class="headerlink" title="如何更新 Q table"></a>如何更新 Q table</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"># 获取第一次观察结果</span><br><span class="line">obs = env.reset()</span><br><span class="line"></span><br><span class="line">while True:  # 一直循环，直到游戏结束</span><br><span class="line">    action = self.act(obs)  # 根据策略，选择 action</span><br><span class="line">    obs2, reward, done, _ = env.step(action)</span><br><span class="line"></span><br><span class="line">    future = 0.0</span><br><span class="line">    if not done:</span><br><span class="line">        future = np.max(self.q[obs2])  # 获取后一步期望的最大奖励</span><br><span class="line"></span><br><span class="line">    # 更新 Q 表格，保留部分当前值 加上 部分当前奖励和未来一步的最大奖励</span><br><span class="line">    self.q[obs][action] = (1 - self.config[&quot;learning_rate&quot;]) * self.q[obs][action] + self.config[&quot;learning_rate&quot;] * (reward + self.config[&quot;discount&quot;] * future)</span><br><span class="line"></span><br><span class="line">    # 更新</span><br><span class="line">    obs = obs2</span><br><span class="line"></span><br><span class="line">    # 游戏结束，退出循环</span><br><span class="line">    if done:</span><br><span class="line">        break</span><br></pre></td></tr></table></figure><h4 id="explore-exploit-问题"><a href="#explore-exploit-问题" class="headerlink" title="explore / exploit 问题"></a>explore / exploit 问题</h4><p>上面的代码我只提到了 <code>self.act</code> 会根据策略选择 action，那么该如何选择呢？这里就涉及到了 explore exploit tradeoff 的问题了。我们理想中的 action 选择策略是既能充分利用现有学习到的知识，每次都去最大化的最终的reward，这就是 exploit。但是同时，我们也希望我们的选择策略能适当的去探索一下其他路径，不能固定在已经知道的最优选择，避免局部最优解，适当时候也去探索其他路径，可能能发现更加优秀的路径，也就是全局最优解，这就是 explore 问题。</p><p>我们采取了一个概率方案，有一定概率去通过随机选择的方式，探索新路径。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># eps 数值在 [0, 1] ，控制探索的力度，越大探索的越多</span></span><br><span class="line"><span class="keyword">if</span> eps <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">    eps = self.config[<span class="string">"eps"</span>]      </span><br><span class="line"><span class="comment"># epsilon greedy.</span></span><br><span class="line">action = np.argmax(self.q[observation]) <span class="keyword">if</span> np.random.random() &gt; eps <span class="keyword">else</span> self.action_space.sample()</span><br><span class="line"><span class="keyword">return</span> action</span><br></pre></td></tr></table></figure><h4 id="其他没有交代的点"><a href="#其他没有交代的点" class="headerlink" title="其他没有交代的点"></a>其他没有交代的点</h4><p>由于本篇是科普性质，所以没有cover很多其他的问题点，比如学习和探索的因子可以是decay的，刚开始训练的时候学习和探索强度比较大，后续慢慢缩小，这样模型就会慢慢收敛。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://mybinder.org/v2/gh/howl-anderson/q_learning_demo/master?filepath=jupyter_notebooks%2Fproof-of-concept.ipynb&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;img src=&quot;https://mybinder.org/badge.svg&quot; alt=&quot;Binder&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;TL;DR&lt;/strong&gt; 从零开始实现 Q-learning 算法，在 OpenAI Gym 的环境中演示：如何一步步实现增强学习。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Reinforcement Learning" scheme="https://blog.xiaoquankong.ai/tags/Reinforcement-Learning/"/>
    
      <category term="OpenAI Gym" scheme="https://blog.xiaoquankong.ai/tags/OpenAI-Gym/"/>
    
      <category term="Q-Learning" scheme="https://blog.xiaoquankong.ai/tags/Q-Learning/"/>
    
  </entry>
  
  <entry>
    <title>python mock 遇到的一个坑</title>
    <link href="https://blog.xiaoquankong.ai/python-mock-%E9%81%87%E5%88%B0%E7%9A%84%E4%B8%80%E4%B8%AA%E5%9D%91/"/>
    <id>https://blog.xiaoquankong.ai/python-mock-遇到的一个坑/</id>
    <published>2018-08-13T11:08:02.494Z</published>
    <updated>2018-08-13T11:08:02.494Z</updated>
    
    <content type="html"><![CDATA[<p>修改一个项目的 Unit Test 代码时，遇到一个关于 <code>mock</code> 的问题点，花了我很久时间才，找到解决方案。特此记录一下，提醒自己，提示他人。<a href="https://mybinder.org/v2/gh/howl-anderson/howl-anderson.github.io/master?filepath=python-mock-%25E9%2581%2587%25E5%2588%25B0%25E7%259A%2584%25E4%25B8%2580%25E4%25B8%25AA%25E5%259D%2591%2Fmain.py.ipynb" target="_blank" rel="noopener"><img src="https://mybinder.org/badge.svg" alt="Binder"></a></p><a id="more"></a><p>&lt;- 吐槽开始</p><p>参与开源项目，最令人头疼的东西，不是他们的代码有多么先进（当然有些项目的代码确实很让人震惊，使用了一些从未听过的库、特性和设计方案：比如 TensorFlow），真正让人震惊的是：开源软件对软件工程的实践。我相信很多企业开发人员和我一样，虽然公司已经比较大型，开发人员众多，公司业务已经达到日均千万次，软件开发人员的素质也很高，个人能力也属于业内能力数一数二的，但是从软件开发过程的角度来说，由于种种内部和外界的因素，导致我们的软件工程实践长期停留在 “家庭作坊式”，但是当我们参与一个大中型 (大约 1K+ star) 开源软件时，我们才意识到外国开发者对于软件工程的理解和使用确实是超出中国十万光年啊 （毕竟软件工程就是歪果仁发明的，多数时候，我们只是照猫画虎）。</p><p>吐槽结束 -&gt;</p><p>我给一个开源软件贡献 PR 时，遇到一个大的问题是我总是要给我的代码写单元测试，会出现一些奇怪的问题（我以为的，实际最后往往证明是我蠢 :( ，本例就是)</p><p>经过简化，最小可复现问题代码集如下：</p><h2 id="文件-dependency-py"><a href="#文件-dependency-py" class="headerlink" title="文件 dependency.py"></a>文件 dependency.py</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">some_funny_func</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">'funny'</span></span><br></pre></td></tr></table></figure><h2 id="文件-module-py"><a href="#文件-module-py" class="headerlink" title="文件 module.py"></a>文件 module.py</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> dependency <span class="keyword">import</span> some_funny_func</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">call_func</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">return</span> some_funny_func()</span><br></pre></td></tr></table></figure><h2 id="文件-tester-py"><a href="#文件-tester-py" class="headerlink" title="文件 tester.py"></a>文件 tester.py</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> unittest.mock <span class="keyword">import</span> patch</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> module <span class="keyword">import</span> call_func</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_call_func</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mocked_funny_func</span><span class="params">()</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"not funny at all"</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">with</span> patch(<span class="string">"dependency.some_funny_func"</span>, mocked_funny_func):</span><br><span class="line">        return_value = call_func()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">assert</span> return_value == <span class="string">"not funny at all"</span></span><br></pre></td></tr></table></figure><p>一切看似合情合理（有些高手，可能已经发现问题了，但我当时没有看出来问题），但是就是通过不了测试。</p><p>这里的错误是，没有深入理解 <code>patch</code> 的工作原理，<code>patch</code> 通过修改 module 属性的方式工作。这里 <code>from module import call_func</code> 执行的时候已经经 <code>dependency.some_funny_func</code> 导入了 <code>module</code>， 换言之：<code>module.some_funny_func</code> 已经指向了 <code>dependency.some_funny_func</code>, 此时通过 <code>patch(&quot;dependency.some_funny_func&quot;, mocked_funny_func)</code> 只是修改了 <code>dependency.some_funny_func</code> 至新的 <code>mocked_funny_func</code>. 但不能修改 <code>module.some_funny_func</code>, 因为这个是修改前赋值的，它现在依旧指向原来的函数。</p><p>将上述改写成 python 代码，原理大概如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 模拟 dependency.some_funny_func</span></span><br><span class="line">dependency = &#123;&#125;</span><br><span class="line">dependency[<span class="string">"some_funny_func"</span>] = <span class="string">"some_value"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 模拟 module.some_funny_func</span></span><br><span class="line">module = &#123;&#125;</span><br><span class="line">module[<span class="string">"some_funny_func"</span>] = dependency[<span class="string">"some_funny_func"</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 模拟 mock</span></span><br><span class="line">dependency[<span class="string">"some_funny_func"</span>] = <span class="string">"some_other_value"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看结果</span></span><br><span class="line">print(dependency[<span class="string">"some_funny_func"</span>])</span><br><span class="line">print(module[<span class="string">"some_funny_func"</span>])</span><br></pre></td></tr></table></figure><h1 id="在线演示"><a href="#在线演示" class="headerlink" title="在线演示"></a>在线演示</h1><p><a href="https://mybinder.org/v2/gh/howl-anderson/howl-anderson.github.io/master?filepath=python-mock-%25E9%2581%2587%25E5%2588%25B0%25E7%259A%2584%25E4%25B8%2580%25E4%25B8%25AA%25E5%259D%2591%2Fmain.py.ipynb" target="_blank" rel="noopener">在线演示地址</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;修改一个项目的 Unit Test 代码时，遇到一个关于 &lt;code&gt;mock&lt;/code&gt; 的问题点，花了我很久时间才，找到解决方案。特此记录一下，提醒自己，提示他人。&lt;a href=&quot;https://mybinder.org/v2/gh/howl-anderson/howl-anderson.github.io/master?filepath=python-mock-%25E9%2581%2587%25E5%2588%25B0%25E7%259A%2584%25E4%25B8%2580%25E4%25B8%25AA%25E5%259D%2591%2Fmain.py.ipynb&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;img src=&quot;https://mybinder.org/badge.svg&quot; alt=&quot;Binder&quot;&gt;&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="python" scheme="https://blog.xiaoquankong.ai/tags/python/"/>
    
      <category term="mock" scheme="https://blog.xiaoquankong.ai/tags/mock/"/>
    
  </entry>
  
  <entry>
    <title>python iterator 遇到的一个坑</title>
    <link href="https://blog.xiaoquankong.ai/python-iterator-%E9%81%87%E5%88%B0%E7%9A%84%E4%B8%80%E4%B8%AA%E5%9D%91/"/>
    <id>https://blog.xiaoquankong.ai/python-iterator-遇到的一个坑/</id>
    <published>2018-08-13T11:08:02.493Z</published>
    <updated>2018-08-13T11:08:02.493Z</updated>
    
    <content type="html"><![CDATA[<p>在使用 Python 的 iterator 时，遇到一个很愚蠢的错误，浪费的很多时间才找到原因。特此记录一下，提醒自己，提示他人。<br><a href="https://mybinder.org/v2/gh/howl-anderson/howl-anderson.github.io/master?filepath=python-iterator-%E9%81%87%E5%88%B0%E7%9A%84%E4%B8%80%E4%B8%AA%E5%9D%91%2Fproof-of-concept.ipynb" target="_blank" rel="noopener"><img src="https://mybinder.org/badge.svg" alt="Binder"></a><br><a id="more"></a></p><h2 id="Bug-复现"><a href="#Bug-复现" class="headerlink" title="Bug 复现"></a>Bug 复现</h2><p>原来的问题比较复杂，导致出错难以调试，经过将问题不断简化，最后简化后的代码如下：</p><h3 id="打印-iterator-的函数"><a href="#打印-iterator-的函数" class="headerlink" title="打印 iterator 的函数"></a>打印 iterator 的函数</h3><p>我们定义一个用于打印 iterator 的函数<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">print_iterator</span><span class="params">(iterator)</span>:</span></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            element = next(iterator)</span><br><span class="line">        <span class="keyword">except</span> StopIteration:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            print(element)</span><br></pre></td></tr></table></figure></p><p>测试一下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print_iterator(iter([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]))</span><br></pre></td></tr></table></figure><p>输出：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td></tr></table></figure></p><p>代码工作正常</p><h3 id="定义一个计算-iterable-长度的函数"><a href="#定义一个计算-iterable-长度的函数" class="headerlink" title="定义一个计算 iterable 长度的函数"></a>定义一个计算 iterable 长度的函数</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">counter_iterable</span><span class="params">(iterable)</span>:</span></span><br><span class="line">    iterator = iter(iterable)</span><br><span class="line">    iterator_length = sum(<span class="number">1</span> <span class="keyword">for</span> _ <span class="keyword">in</span> iterator)</span><br><span class="line"></span><br><span class="line">    print(iterator_length)</span><br></pre></td></tr></table></figure><p>测试一下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">counter_iterable([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br></pre></td></tr></table></figure><p>输出：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure></p><p>代码工作正常</p><h3 id="整合在一起"><a href="#整合在一起" class="headerlink" title="整合在一起"></a>整合在一起</h3><p>将 <code>放在</code> 中调用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">def counter_iterable_and_print(iterable):</span><br><span class="line">    iterator = iter(iterable)</span><br><span class="line">    iterator_length = sum(1 for _ in iterator)</span><br><span class="line"></span><br><span class="line">    print(iterator_length)</span><br><span class="line"></span><br><span class="line">    print_iterator(iterator)</span><br></pre></td></tr></table></figure><p>测试一下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">counter_iterable_and_print([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br></pre></td></tr></table></figure><p>期望的输出应该有长度和打印内容两个部分构成：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td></tr></table></figure></p><p>但实际上输出是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure><p>代码工作不正常</p><h2 id="bug-原因"><a href="#bug-原因" class="headerlink" title="bug 原因"></a>bug 原因</h2><p>这个 bug 的产生和我对两个概念的理解和记忆错误有关：<br>第一个是没有充分理解和记忆 iterator 的工作机制。</p><h3 id="iterator-是什么"><a href="#iterator-是什么" class="headerlink" title="iterator 是什么"></a>iterator 是什么</h3><p>根据 <a href="https://wiki.python.org/moin/Iterator" target="_blank" rel="noopener">Iterator on Python wiki</a> :</p><blockquote><p> An <code>iterator</code> is an object that implements <code>next</code> (in python3, it is <code>__next__</code>) method, which is expected to return the next element of the iterable object that returned it, and raise a <code>StopIteration</code> exception when no more elements are available.</p><p> <code>Iterator</code> will typically need to maintain some kind of position state information (like the index of the last element returned or the like). If the iterable maintained that state itself, it would become inherently non-reentrant (meaning you could use it only one loop at a time).</p></blockquote><p>上述 bug 产生的原因：上面的代码中共享了一个 <code>iterator</code> 对象，由于 <code>iterator</code> 具有记忆内部状态的能力，所以当<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iterator_length = sum(1 for _ in iterator)</span><br></pre></td></tr></table></figure></p><p>执行完毕后，实际这个 <code>iterator</code> 对象已经完成了全部元素的迭代。后续再次调用这个对象的 <code>__next__()</code> 方法时，直接抛出 <code>StopIteration</code> 异常。因此这就是为什么后续的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print_iterator(iterator)</span><br></pre></td></tr></table></figure></p><p>并没有任何输出的原因，因为函数收到的参数已经是一个走到最后的 <code>iterator</code> 对象了。</p><p><code>iterator</code> 内有有状态信息，具有不可重入（non-reentrant）的特性，这个和 <code>list</code>, <code>tuple</code>, <code>dict</code> 等容器不一样，容器通过 <code>__getitem__</code> 来迭代。</p><p>另外一个是没有搞清楚 <code>iterable</code> 和 <code>iterator</code> 的区别。正确的理解是：<code>iterable</code> 是一个工厂函数，通过显式的调用 <code>iter</code> 函数或者调用其 <code>__iter__()</code> 方法或者使用 <code>for</code> 循环来获得这个工厂的产品：一个 <code>iterator</code> 对象。</p><p>这里需要简单说明的是：无论是使用 <code>iter</code> 函数还是在 for 循环中使用，都是间接的调用 <code>iterable</code> 对象的 <code>__iter__</code> 方法。</p><p><code>iterator</code> 被要求需要支持 <code>iterable</code> 协议的。通常情况下，对 <code>iterator</code> 调用 <code>__iter__</code> 方法，返回的 <code>iterator</code> 就是它自己。 这样 <code>iterator</code> 对象就能够在 for-loop 中使用了。</p><p>关于 <code>iterator</code> 的 PEP 在 <a href="https://www.python.org/dev/peps/pep-0234/" target="_blank" rel="noopener">PEP 234 – Iterators</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在使用 Python 的 iterator 时，遇到一个很愚蠢的错误，浪费的很多时间才找到原因。特此记录一下，提醒自己，提示他人。&lt;br&gt;&lt;a href=&quot;https://mybinder.org/v2/gh/howl-anderson/howl-anderson.github.io/master?filepath=python-iterator-%E9%81%87%E5%88%B0%E7%9A%84%E4%B8%80%E4%B8%AA%E5%9D%91%2Fproof-of-concept.ipynb&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;img src=&quot;https://mybinder.org/badge.svg&quot; alt=&quot;Binder&quot;&gt;&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="python" scheme="https://blog.xiaoquankong.ai/tags/python/"/>
    
      <category term="iterable" scheme="https://blog.xiaoquankong.ai/tags/iterable/"/>
    
      <category term="iterator" scheme="https://blog.xiaoquankong.ai/tags/iterator/"/>
    
  </entry>
  
  <entry>
    <title>「盤古之白」</title>
    <link href="https://blog.xiaoquankong.ai/%E3%80%8C%E7%9B%A4%E5%8F%A4%E4%B9%8B%E7%99%BD%E3%80%8D/"/>
    <id>https://blog.xiaoquankong.ai/「盤古之白」/</id>
    <published>2018-01-23T18:56:26.000Z</published>
    <updated>2018-08-13T11:08:02.495Z</updated>
    
    <content type="html"><![CDATA[<p><strong>TL;DR</strong> 中文文案排版指南</p><a id="more"></a><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><h3 id="排版的重要性"><a href="#排版的重要性" class="headerlink" title="排版的重要性"></a>排版的重要性</h3><p>中文文案排版是每一个现代人或多或少都要进行的职业活动。但是文案排版不是一个容易的工作，有很多人一直都在使用错误的方式排版文案。排版错误或者不美观的文案将影响文案的宣传和传播效果，尤其是你的申请表、简历、个人介绍等，影响深远！</p><h3 id="符号约定"><a href="#符号约定" class="headerlink" title="符号约定"></a>符号约定</h3><p>为了让空格更容易被识别出来，本文余下内容中将使用☐ (U+2610 BALLOT BOX（方格）) 表示空格</p><h3 id="版权相关"><a href="#版权相关" class="headerlink" title="版权相关"></a>版权相关</h3><p>本文中的多数内容都是基于参考文献的衍生和再创造，特此申明！</p><h2 id="空格的使用"><a href="#空格的使用" class="headerlink" title="空格的使用"></a>空格的使用</h2><blockquote><p>「為什麼你們就是不能加個空格呢？」</p></blockquote><p>by <a href="https://github.com/vinta/pangu.js" target="_blank" rel="noopener">https://github.com/vinta/pangu.js</a></p><h3 id="中英文之間需要增加空格"><a href="#中英文之間需要增加空格" class="headerlink" title="中英文之間需要增加空格"></a>中英文之間需要增加空格</h3><h4 id="正确的做法"><a href="#正确的做法" class="headerlink" title="正确的做法"></a>正确的做法</h4><p>排版效果：</p><blockquote><p>在 LeanCloud 上，数据存储是围绕 <code>AVObject</code> 进行的。</p></blockquote><p>排版方案：</p><blockquote><p>在☐LeanCloud☐上，数据存储是围绕☐<code>AVObject</code>☐进行的。</p></blockquote><h4 id="错误的做法"><a href="#错误的做法" class="headerlink" title="错误的做法"></a>错误的做法</h4><blockquote><p>在LeanCloud上，数据存储是围绕<code>AVObject</code>进行的。</p><p>在 LeanCloud上，数据存储是围绕<code>AVObject</code> 进行的。</p></blockquote><h4 id="例外情况"><a href="#例外情况" class="headerlink" title="例外情况"></a>例外情况</h4><p>例如「豆瓣FM」之类的产品名称等专有名词，按照产品官方定义的格式书写。</p><h3 id="中文与数字之间需要增加空格"><a href="#中文与数字之间需要增加空格" class="headerlink" title="中文与数字之间需要增加空格"></a>中文与数字之间需要增加空格</h3><h4 id="正确的做法-1"><a href="#正确的做法-1" class="headerlink" title="正确的做法"></a>正确的做法</h4><blockquote><p>今天出去买菜花了 5000 元。</p></blockquote><h4 id="错误的做法-1"><a href="#错误的做法-1" class="headerlink" title="错误的做法"></a>错误的做法</h4><blockquote><p>今天出去买菜花了5000元。</p><p>今天出去买菜花了 5000元。</p></blockquote><h3 id="数字和单位之间需要增加空格"><a href="#数字和单位之间需要增加空格" class="headerlink" title="数字和单位之间需要增加空格"></a>数字和单位之间需要增加空格</h3><p><em>NOTE：</em> 很典型的错误的！:(</p><h4 id="正确的做法-2"><a href="#正确的做法-2" class="headerlink" title="正确的做法"></a>正确的做法</h4><blockquote><p>我家的光纤入屋带宽有 10 Gbps，SSD 一共有 20 TB。</p></blockquote><h4 id="错误的做法-2"><a href="#错误的做法-2" class="headerlink" title="错误的做法"></a>错误的做法</h4><blockquote><p>我家的光纤入屋带宽有 10Gbps，SSD 一共有 20TB。</p></blockquote><h4 id="例外情况-1"><a href="#例外情况-1" class="headerlink" title="例外情况"></a>例外情况</h4><p>度／百分比與數字之間不需要增加空格</p><h5 id="温度"><a href="#温度" class="headerlink" title="温度"></a>温度</h5><h6 id="正确的做法-3"><a href="#正确的做法-3" class="headerlink" title="正确的做法"></a>正确的做法</h6><blockquote><p>今天是 233° 的高溫。</p></blockquote><h6 id="错误的做法-3"><a href="#错误的做法-3" class="headerlink" title="错误的做法"></a>错误的做法</h6><blockquote><p>今天是 233 ° 的高溫。</p></blockquote><h5 id="百分比"><a href="#百分比" class="headerlink" title="百分比"></a>百分比</h5><h6 id="正确的做法-4"><a href="#正确的做法-4" class="headerlink" title="正确的做法"></a>正确的做法</h6><blockquote><p>新 MacBook Pro 有 15% 的 CPU 性能提升。</p></blockquote><h6 id="错误的做法-4"><a href="#错误的做法-4" class="headerlink" title="错误的做法"></a>错误的做法</h6><blockquote><p>新 MacBook Pro 有 15 % 的 CPU 性能提升。</p></blockquote><h3 id="全形（全角）標點與其他字符之間不加空格"><a href="#全形（全角）標點與其他字符之間不加空格" class="headerlink" title="全形（全角）標點與其他字符之間不加空格"></a>全形（全角）標點與其他字符之間不加空格</h3><h4 id="正确的做法-5"><a href="#正确的做法-5" class="headerlink" title="正确的做法"></a>正确的做法</h4><blockquote><p>剛剛買了一部 iPhone，好開心！</p></blockquote><h4 id="错误的做法-5"><a href="#错误的做法-5" class="headerlink" title="错误的做法"></a>错误的做法</h4><blockquote><p>剛剛買了一部 iPhone ，好開心！</p></blockquote><h2 id="其他非空格相关的排版问题"><a href="#其他非空格相关的排版问题" class="headerlink" title="其他非空格相关的排版问题"></a>其他非空格相关的排版问题</h2><h3 id="常见错误类"><a href="#常见错误类" class="headerlink" title="常见错误类"></a>常见错误类</h3><h4 id="中文环境使用半角符号是错误的！"><a href="#中文环境使用半角符号是错误的！" class="headerlink" title="中文环境使用半角符号是错误的！"></a>中文环境使用半角符号是错误的！</h4><h5 id="正确的做法-6"><a href="#正确的做法-6" class="headerlink" title="正确的做法"></a>正确的做法</h5><p>排版效果：</p><blockquote><p>嗨！你知道嘛？今天前台的小妹跟我說「喵」了哎！</p></blockquote><p>排版方案：</p><blockquote><p>嗨！你知道嘛？今天前台的小妹跟我說「喵」了哎！</p></blockquote><p><em>NOTE：</em> 上文文字间没有☐，也就是没有空格。</p><h5 id="错误的做法-6"><a href="#错误的做法-6" class="headerlink" title="错误的做法"></a>错误的做法</h5><p>排版效果：</p><blockquote><p>嗨! 你知道嘛? 今天前台的小妹跟我說 “喵” 了哎!</p></blockquote><p>排版方案：</p><blockquote><p>嗨!☐你知道嘛?☐今天前台的小妹跟我說☐”喵”☐了哎!</p></blockquote><p><em>NOTE：</em> 这种错误还挺常见的！</p><h4 id="專有名詞使用正確的大小寫"><a href="#專有名詞使用正確的大小寫" class="headerlink" title="專有名詞使用正確的大小寫"></a>專有名詞使用正確的大小寫</h4><h5 id="正确的做法-7"><a href="#正确的做法-7" class="headerlink" title="正确的做法"></a>正确的做法</h5><blockquote><p>我們的客戶有 GitHub、Foursquare、Microsoft Corporation、Google、Facebook, Inc.。</p></blockquote><h5 id="错误的做法-7"><a href="#错误的做法-7" class="headerlink" title="错误的做法"></a>错误的做法</h5><blockquote><p>我們的客戶有 github、foursquare、microsoft corporation、google、facebook, inc.。</p></blockquote><p><em>NOTE：</em> 看完之后，多数人都有想立即把首字母改成大写的冲动，真的！</p><h4 id="不要使用不地道的縮寫"><a href="#不要使用不地道的縮寫" class="headerlink" title="不要使用不地道的縮寫"></a>不要使用不地道的縮寫</h4><h5 id="正确的做法-8"><a href="#正确的做法-8" class="headerlink" title="正确的做法"></a>正确的做法</h5><blockquote><p>我們需要一位熟悉 JavaScript、HTML5，至少理解一种框架（如 Backbone.js、AngularJS、React 等）的前端開發者。</p></blockquote><h5 id="错误的做法-8"><a href="#错误的做法-8" class="headerlink" title="错误的做法"></a>错误的做法</h5><blockquote><p>我們需要一位熟悉 Js、h5，至少理解一种框架（如 backbone、angular、RJS 等）的 FED。</p></blockquote><p><em>NOTE：</em> 错误到简直辣眼睛！千万不要出现在你的简历里，真的拜托了🙏！</p><h3 id="略有争议但我（作者个人）觉得正确的常见错误类"><a href="#略有争议但我（作者个人）觉得正确的常见错误类" class="headerlink" title="略有争议但我（作者个人）觉得正确的常见错误类"></a>略有争议但我（作者个人）觉得正确的常见错误类</h3><h4 id="链接之间增加空格"><a href="#链接之间增加空格" class="headerlink" title="链接之间增加空格"></a>链接之间增加空格</h4><h5 id="正确的做法-9"><a href="#正确的做法-9" class="headerlink" title="正确的做法"></a>正确的做法</h5><blockquote><p>访问我们网站的最新动态，请 <a href="#">点击这里</a> 进行订阅！</p></blockquote><h5 id="错误的做法-9"><a href="#错误的做法-9" class="headerlink" title="错误的做法"></a>错误的做法</h5><blockquote><p>访问我们网站的最新动态，请<a href="#">点击这里</a>进行订阅！</p></blockquote><p><em>NOTE：</em> 链接文字和普通文字挤在一起的感觉，让人觉得很业余！</p><h4 id="简体中文使用直角引号（这个还真是挺争议的）"><a href="#简体中文使用直角引号（这个还真是挺争议的）" class="headerlink" title="简体中文使用直角引号（这个还真是挺争议的）"></a>简体中文使用直角引号（这个还真是挺争议的）</h4><h5 id="正确的做法-10"><a href="#正确的做法-10" class="headerlink" title="正确的做法"></a>正确的做法</h5><blockquote><p>「老师，『有条不紊』的『紊』是什么意思？」</p></blockquote><p><em>NOTE：</em> 感觉正体很帅，很正式！</p><h5 id="错误的做法-10"><a href="#错误的做法-10" class="headerlink" title="错误的做法"></a>错误的做法</h5><blockquote><p>“老师，‘有条不紊’的‘紊’是什么意思？”</p></blockquote><h5 id="怎么输入直角引号（i-e-「、」、『、』）"><a href="#怎么输入直角引号（i-e-「、」、『、』）" class="headerlink" title="怎么输入直角引号（i.e.「、」、『、』）"></a>怎么输入直角引号（i.e.「、」、『、』）</h5><p>见知乎：<a href="https://www.zhihu.com/question/19755746" target="_blank" rel="noopener">如何输入直角引号（「」和『』 ）？</a></p><h3 id="不常见错误类"><a href="#不常见错误类" class="headerlink" title="不常见错误类"></a>不常见错误类</h3><p>既然是不常见的错误，那么本文就不再讨论了，读者还是去看附在文末的参考文献吧，里面什么都有！</p><h2 id="「盤古之白」是什么意思？"><a href="#「盤古之白」是什么意思？" class="headerlink" title="「盤古之白」是什么意思？"></a>「盤古之白」是什么意思？</h2><p>所有的中文字和半形的英文、數字、符號之間应该存在的空白，被漢學家稱為「盤古之白」，因為它劈開了全形字和半形字之間的混沌。</p><blockquote><p>另有研究顯示，打字的時候不喜歡在中文和英文之間加空格的人，感情路都走得很辛苦，有七成的比例會在 34 歲的時候跟自己不愛的人結婚，而其餘三成的人最後只能把遺產留給自己的貓。畢竟愛情跟書寫都需要適時地留白。</p><p>與大家共勉之。</p></blockquote><p>by <a href="https://github.com/vinta/pangu.js" target="_blank" rel="noopener">https://github.com/vinta/pangu.js</a></p><h2 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h2><table><thead><tr><th>仓库</th><th>语言</th></tr></thead><tbody><tr><td><a href="https://github.com/vinta/paranoid-auto-spacing" target="_blank" rel="noopener">vinta/paranoid-auto-spacing</a></td><td>JavaScript</td></tr><tr><td><a href="https://github.com/huei90/pangu.node" target="_blank" rel="noopener">huei90/pangu.node</a></td><td>Node.js</td></tr><tr><td><a href="https://github.com/huacnlee/auto-correct" target="_blank" rel="noopener">huacnlee/auto-correct</a></td><td>Ruby</td></tr><tr><td><a href="https://github.com/sparanoid/space-lover" target="_blank" rel="noopener">sparanoid/space-lover</a></td><td>PHP (WordPress)</td></tr><tr><td><a href="https://github.com/NauxLiu/auto-correct" target="_blank" rel="noopener">nauxliu/auto-correct</a></td><td>PHP</td></tr><tr><td><a href="https://github.com/ricoa/copywriting-correct" target="_blank" rel="noopener">ricoa/copywriting-correct</a></td><td>PHP</td></tr><tr><td><a href="https://github.com/hotoo/pangu.vim" target="_blank" rel="noopener">hotoo/pangu.vim</a></td><td>Vim</td></tr><tr><td><a href="https://github.com/sparanoid/grunt-auto-spacing" target="_blank" rel="noopener">sparanoid/grunt-auto-spacing</a></td><td>Node.js (Grunt)</td></tr><tr><td><a href="https://github.com/hjiang/scripts/blob/master/add-space-between-latin-and-cjk" target="_blank" rel="noopener">hjiang/scripts/add-space-between-latin-and-cjk</a></td><td>Python</td></tr></tbody></table><h2 id="谁在这样做？"><a href="#谁在这样做？" class="headerlink" title="谁在这样做？"></a>谁在这样做？</h2><table><thead><tr><th>网站</th><th>文案</th><th>UGC</th></tr></thead><tbody><tr><td><a href="http://www.apple.com/cn/" target="_blank" rel="noopener">Apple 中国</a></td><td>Yes</td><td>N/A</td></tr><tr><td><a href="http://www.apple.com/hk/" target="_blank" rel="noopener">Apple 香港</a></td><td>Yes</td><td>N/A</td></tr><tr><td><a href="http://www.apple.com/tw/" target="_blank" rel="noopener">Apple 台湾</a></td><td>Yes</td><td>N/A</td></tr><tr><td><a href="http://www.microsoft.com/zh-cn/" target="_blank" rel="noopener">Microsoft 中国</a></td><td>Yes</td><td>N/A</td></tr><tr><td><a href="http://www.microsoft.com/zh-hk/" target="_blank" rel="noopener">Microsoft 香港</a></td><td>Yes</td><td>N/A</td></tr><tr><td><a href="http://www.microsoft.com/zh-tw/" target="_blank" rel="noopener">Microsoft 台湾</a></td><td>Yes</td><td>N/A</td></tr><tr><td><a href="https://leancloud.cn/" target="_blank" rel="noopener">LeanCloud</a></td><td>Yes</td><td>N/A</td></tr><tr><td><a href="https://www.zhihu.com/" target="_blank" rel="noopener">知乎</a></td><td>Yes</td><td>部分用户达成</td></tr><tr><td><a href="https://www.v2ex.com/" target="_blank" rel="noopener">V2EX</a></td><td>Yes</td><td>Yes</td></tr><tr><td><a href="https://segmentfault.com/" target="_blank" rel="noopener">SegmentFault</a></td><td>Yes</td><td>部分用户达成</td></tr><tr><td><a href="http://apple4us.com/" target="_blank" rel="noopener">Apple4us</a></td><td>Yes</td><td>N/A</td></tr><tr><td><a href="https://www.wandoujia.com/" target="_blank" rel="noopener">豌豆荚</a></td><td>Yes</td><td>N/A</td></tr><tr><td><a href="https://ruby-china.org/" target="_blank" rel="noopener">Ruby China</a></td><td>Yes</td><td>标题达成</td></tr><tr><td><a href="https://phphub.org/" target="_blank" rel="noopener">PHPHub</a></td><td>Yes</td><td>标题达成</td></tr><tr><td><a href="http://sspai.com/" target="_blank" rel="noopener">少数派</a></td><td>Yes</td><td>N/A</td></tr><tr><td><a href="http://blog.xiaoquankong.ai/">blog.xiaoquankong.ai (本站啦)</a></td><td>Yes</td><td>作者还在努力推进中 :)</td></tr></tbody></table><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="https://github.com/sparanoid/chinese-copywriting-guidelines/blob/master/README.md" target="_blank" rel="noopener">中文文案排版指北</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;TL;DR&lt;/strong&gt; 中文文案排版指南&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Chinese Spelling Check Task: 资料汇总</title>
    <link href="https://blog.xiaoquankong.ai/Chinese-Spelling-Check-Task-%E8%B5%84%E6%96%99%E6%B1%87%E6%80%BB/"/>
    <id>https://blog.xiaoquankong.ai/Chinese-Spelling-Check-Task-资料汇总/</id>
    <published>2018-01-16T10:24:24.000Z</published>
    <updated>2018-08-13T11:08:02.482Z</updated>
    
    <content type="html"><![CDATA[<p><strong>TL;DR</strong> 一些关于 Chinese Spelling Check Task 比较重要的会议和资料的整理和汇总。</p><a id="more"></a><h1 id="重要的相关会议"><a href="#重要的相关会议" class="headerlink" title="重要的相关会议"></a>重要的相关会议</h1><h2 id="ACL"><a href="#ACL" class="headerlink" title="ACL"></a>ACL</h2><h2 id="ACLCLP"><a href="#ACLCLP" class="headerlink" title="ACLCLP"></a>ACLCLP</h2><p>ACLCLP 是 Association for Computational Linguistics and Chinese Language Processing 的缩写。</p><h1 id="数据集"><a href="#数据集" class="headerlink" title="数据集"></a>数据集</h1><h2 id="Chinese-Grammatical-Error-Diagnosis"><a href="#Chinese-Grammatical-Error-Diagnosis" class="headerlink" title="Chinese Grammatical Error Diagnosis"></a>Chinese Grammatical Error Diagnosis</h2><p>NLPTEA 2016 Shared Task: <a href="http://ir.itc.ntnu.edu.tw/lre/nlptea16cged.htm" target="_blank" rel="noopener">http://ir.itc.ntnu.edu.tw/lre/nlptea16cged.htm</a><br>NLPTEA 2015 Shared Task: <a href="http://ir.itc.ntnu.edu.tw/lre/nlptea15cged.htm" target="_blank" rel="noopener">http://ir.itc.ntnu.edu.tw/lre/nlptea15cged.htm</a><br>NLPTEA 2014 Shared Task: <a href="http://ir.itc.ntnu.edu.tw/lre/nlptea14cfl.htm" target="_blank" rel="noopener">http://ir.itc.ntnu.edu.tw/lre/nlptea14cfl.htm</a></p><h2 id="Chinese-Spelling-Check"><a href="#Chinese-Spelling-Check" class="headerlink" title="Chinese Spelling Check"></a>Chinese Spelling Check</h2><p>SIGHAN 2015 Bake-off: <a href="http://ir.itc.ntnu.edu.tw/lre/sighan8csc.html" target="_blank" rel="noopener">http://ir.itc.ntnu.edu.tw/lre/sighan8csc.html</a><br>CLP 2014 Bake-off: <a href="http://ir.itc.ntnu.edu.tw/lre/clp14csc.html" target="_blank" rel="noopener">http://ir.itc.ntnu.edu.tw/lre/clp14csc.html</a><br>SIGHAN 2013 Bake-off: <a href="http://ir.itc.ntnu.edu.tw/lre/sighan7csc.html" target="_blank" rel="noopener">http://ir.itc.ntnu.edu.tw/lre/sighan7csc.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;TL;DR&lt;/strong&gt; 一些关于 Chinese Spelling Check Task 比较重要的会议和资料的整理和汇总。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>TenserFlow 新特性：Eager Execution</title>
    <link href="https://blog.xiaoquankong.ai/TenserFlow-%E6%96%B0%E7%89%B9%E6%80%A7%EF%BC%9AEager-Execution/"/>
    <id>https://blog.xiaoquankong.ai/TenserFlow-新特性：Eager-Execution/</id>
    <published>2017-12-23T13:16:51.000Z</published>
    <updated>2018-08-13T11:08:02.491Z</updated>
    
    <content type="html"><![CDATA[<!-- TODO: https://github.com/hexojs/hexo/issues/2150 caused can not use GitHub badge --><p><strong>TL;DR</strong> 在即将发布（本文章写于 2018-01-06）的 TenserFlow v1.5 中，TensorFlow将会引入一个重要的 User-friendly 特性：Eager Execution. 本文章将展示 Eager Execution 引入的一些新的特性。<br><a id="more"></a></p><h1 id="安装-TensorFlow-对应的版本"><a href="#安装-TensorFlow-对应的版本" class="headerlink" title="安装 TensorFlow 对应的版本"></a>安装 TensorFlow 对应的版本</h1><p>因为 TensorFlow 正式版（写作时间 2018-01-06，此时的正式版本为1.4.1）中还不包含此功能，因此我们需要安装 TensorFlow nightly build 版本。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install tf-nightly  <span class="comment"># or tf-nightly-gpu if you have GPU</span></span><br></pre></td></tr></table></figure><h1 id="特性探索"><a href="#特性探索" class="headerlink" title="特性探索"></a>特性探索</h1><h2 id="Eager-execution"><a href="#Eager-execution" class="headerlink" title="Eager execution"></a>Eager execution</h2><p>在开启这个模式后，TensorFlow 将会立即执行操作，返回结果给 Python，而不需要使用 <code>Session.run()</code>, 例如：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"><span class="keyword">import</span> tensorflow.contrib.eager <span class="keyword">as</span> tfe</span><br><span class="line"></span><br><span class="line">tfe.enable_eager_execution()</span><br><span class="line"></span><br><span class="line">x = [[<span class="number">2</span>]]</span><br><span class="line">m = tf.matmul(x, x)</span><br><span class="line"></span><br><span class="line">print(m)</span><br></pre></td></tr></table></figure></p><blockquote><p>点击这里 <a href="https://mybinder.org/v2/gh/howl-anderson/howl-anderson.github.io/master?filepath=binder%2FTenserFlow%20%E6%96%B0%E7%89%B9%E6%80%A7%EF%BC%9AEager%20Execution%2FEager%20execution.ipynb" target="_blank" rel="noopener">launch binder</a> ，在线运行这个例子</p></blockquote><p>你会得到如下显示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tf.Tensor([[4]], shape=(1, 1), dtype=int32)</span><br></pre></td></tr></table></figure></p><h3 id="Dynamic-models"><a href="#Dynamic-models" class="headerlink" title="Dynamic models"></a>Dynamic models</h3><p>在不具备动态模型的能力前，TensorFlow 中的每一个 operator 都需要明确定声明和定义。在具备的了动态模型能力之后，TensorFlow 具备了从操作中推导操作数类型的能力，让复杂的动态模型容易实现，例如：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"><span class="keyword">import</span> tensorflow.contrib.eager <span class="keyword">as</span> tfe</span><br><span class="line"></span><br><span class="line">tfe.enable_eager_execution()</span><br><span class="line"></span><br><span class="line">a = tf.constant(<span class="number">12</span>)</span><br><span class="line">counter = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> <span class="keyword">not</span> tf.equal(a, <span class="number">1</span>):</span><br><span class="line">  <span class="keyword">if</span> tf.equal(a % <span class="number">2</span>, <span class="number">0</span>):</span><br><span class="line">    a = a / <span class="number">2</span></span><br><span class="line">  <span class="keyword">else</span>:</span><br><span class="line">    a = <span class="number">3</span> * a + <span class="number">1</span></span><br><span class="line">  print(a)</span><br></pre></td></tr></table></figure></p><blockquote><p>点击这里 <a href="https://mybinder.org/v2/gh/howl-anderson/howl-anderson.github.io/master?filepath=binder%2FTenserFlow%20%E6%96%B0%E7%89%B9%E6%80%A7%EF%BC%9AEager%20Execution%2FDynamic%20models.ipynb" target="_blank" rel="noopener">launch binder</a> ，在线运行这个例子</p></blockquote><p>如果没有启用 Eager Execution 会显示如下错误：</p><blockquote><p>Using a <code>tf.Tensor</code> as a Python <code>bool</code> is not allowed.</p></blockquote><p>原因是在 <code>while not tf.equal(a, 1)</code> 处，如果没有启动 Eager Execution 那么返回的结果是 <code>tf.Tensor</code> 对象，因为还不知道具体的值所以不能转换成bool类型。</p><h2 id="Gradients"><a href="#Gradients" class="headerlink" title="Gradients"></a>Gradients</h2><p>得益于 Eager Execution 立即执行的特性，Gradients 也可以立即得到，而不用等到运行时才能知道，例子如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"><span class="keyword">import</span> tensorflow.contrib.eager <span class="keyword">as</span> tfe</span><br><span class="line"></span><br><span class="line">tfe.enable_eager_execution()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">square</span><span class="params">(x)</span>:</span></span><br><span class="line">  <span class="keyword">return</span> tf.multiply(x, x)</span><br><span class="line"></span><br><span class="line">grad = tfe.gradients_function(square)</span><br><span class="line"></span><br><span class="line">print(square(<span class="number">3.</span>))    <span class="comment"># 输出 [9.]</span></span><br><span class="line">print(grad(<span class="number">3.</span>))      <span class="comment"># 输出 [6.]</span></span><br></pre></td></tr></table></figure></p><blockquote><p>点击这里 <a href="https://mybinder.org/v2/gh/howl-anderson/howl-anderson.github.io/master?filepath=binder%2FTenserFlow%20%E6%96%B0%E7%89%B9%E6%80%A7%EF%BC%9AEager%20Execution%2FGradients.ipynb" target="_blank" rel="noopener">launch binder</a> ，在线运行这个例子</p></blockquote><p>输入的具体情况如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tf.Tensor(9.0, shape=(), dtype=float32)</span><br><span class="line">[&lt;tf.Tensor: id=11, shape=(), dtype=float32, numpy=6.0&gt;]</span><br></pre></td></tr></table></figure></p><h2 id="Building-models"><a href="#Building-models" class="headerlink" title="Building models"></a>Building models</h2><p>官方推荐应该使用 Python 的 class 来组织模型结构而不是 function。Eager Execution 带有的 <code>tfe.Network</code> 就是设计用来作为模型的父类的，继承这个类之后就支持网络的套嵌，下面这段代码是官方推荐的简易 MNIST 模型的参考：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MNISTModel</span><span class="params">(tfe.Network)</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">    super(MNISTModel, self).__init__()</span><br><span class="line">    self.layer1 = self.track_layer(tf.layers.Dense(units=<span class="number">10</span>))</span><br><span class="line">    self.layer2 = self.track_layer(tf.layers.Dense(units=<span class="number">10</span>))</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">call</span><span class="params">(self, input)</span>:</span></span><br><span class="line">    <span class="string">"""Actually runs the model."""</span></span><br><span class="line">    result = self.layer1(input)</span><br><span class="line">    result = self.layer2(result)</span><br><span class="line">    <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure></p><p>即使没有训练，我们也能够立即调用它并观察输出：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Let's make up a blank input image</span></span><br><span class="line">model = MNISTModel()</span><br><span class="line">batch = tf.zeros([<span class="number">1</span>, <span class="number">1</span>, <span class="number">784</span>])</span><br><span class="line">print(batch.shape)</span><br><span class="line"><span class="comment"># (1, 1, 784)</span></span><br><span class="line">result = model(batch)</span><br><span class="line">print(result)</span><br><span class="line"><span class="comment"># tf.Tensor([[[ 0.  0., ...., 0.]]], shape=(1, 1, 10), dtype=float32)</span></span><br></pre></td></tr></table></figure></p><p>这里并不需要使用 placeholders 或者 sessions。当我们第一输入时，模型的参数会被设定好。</p><p>为了训练任何模型，我们都需要 loss function，calculate gradients 和 optimizer 去优化参数。<br><strong><em>loss function</em></strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">loss_function</span><span class="params">(model, x, y)</span>:</span></span><br><span class="line">    y_ = model(x)</span><br><span class="line">    <span class="keyword">return</span> tf.nn.softmax_cross_entropy_with_logits(labels=y, logits=y_)</span><br></pre></td></tr></table></figure></p><p><strong><em>calculate gradients &amp; optimizer</em></strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">optimizer = tf.train.GradientDescentOptimizer(learning_rate=<span class="number">0.001</span>)</span><br><span class="line"><span class="keyword">for</span> (x, y) <span class="keyword">in</span> tfe.Iterator(dataset):</span><br><span class="line">    grads = tfe.implicit_gradients(loss_function)(model, x, y)</span><br><span class="line">    optimizer.apply_gradients(grads)</span><br></pre></td></tr></table></figure></p><blockquote><p>点击这里 <a href="https://mybinder.org/v2/gh/howl-anderson/howl-anderson.github.io/master?filepath=binder%2FTenserFlow%20%E6%96%B0%E7%89%B9%E6%80%A7%EF%BC%9AEager%20Execution%2FBuilding%20models.ipynb" target="_blank" rel="noopener">launch binder</a> ，在线运行这个例子</p></blockquote><h2 id="其他特性"><a href="#其他特性" class="headerlink" title="其他特性"></a>其他特性</h2><p>还有其他特性，如：</p><ul><li>get the second derivative</li><li>derivative under control flow</li><li>Custom Gradients</li></ul><p>这里就不再介绍，感兴趣的可以参考官方文档或者本文的参考文档。</p><h1 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h1><ul><li><a href="https://research.googleblog.com/2017/10/eager-execution-imperative-define-by.html" target="_blank" rel="noopener">Google Research Blog &gt; Eager Execution: An imperative, define-by-run interface to TensorFlow</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;!-- TODO: https://github.com/hexojs/hexo/issues/2150 caused can not use GitHub badge --&gt;
&lt;p&gt;&lt;strong&gt;TL;DR&lt;/strong&gt; 在即将发布（本文章写于 2018-01-06）的 TenserFlow v1.5 中，TensorFlow将会引入一个重要的 User-friendly 特性：Eager Execution. 本文章将展示 Eager Execution 引入的一些新的特性。&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Netgear WNDR4300路由器LEDE环境自动路由切换技术</title>
    <link href="https://blog.xiaoquankong.ai/Netgear-WNDR4300%E8%B7%AF%E7%94%B1%E5%99%A8LEDE%E7%8E%AF%E5%A2%83%E8%87%AA%E5%8A%A8%E8%B7%AF%E7%94%B1%E5%88%87%E6%8D%A2%E6%8A%80%E6%9C%AF/"/>
    <id>https://blog.xiaoquankong.ai/Netgear-WNDR4300路由器LEDE环境自动路由切换技术/</id>
    <published>2017-11-27T06:49:59.000Z</published>
    <updated>2018-08-13T11:08:02.483Z</updated>
    
    <content type="html"><![CDATA[<p><strong>TL;DR</strong> 本文将介绍自动路由切换技术，这是作为专业的程序狗必备的生产性技能。<br><a id="more"></a></p><h1 id="路由器刷LEDE"><a href="#路由器刷LEDE" class="headerlink" title="路由器刷LEDE"></a>路由器刷LEDE</h1><p>不再详述，见 <a href="/Netgear-WNDR4300固件刷openwrt-LEDE/">Netgear WNDR4300固件刷openwrt/LEDE</a></p><h1 id="自动路由技术原理解析"><a href="#自动路由技术原理解析" class="headerlink" title="自动路由技术原理解析"></a>自动路由技术原理解析</h1><p>浏览器访问一个网站通过两个阶段完成：</p><ul><li>解析网站的域名到IP</li><li>HTTP请求这个IP</li></ul><p>下面我们将按照这个顺序依次解决。</p><h2 id="DNS解析技术"><a href="#DNS解析技术" class="headerlink" title="DNS解析技术"></a>DNS解析技术</h2><p>因为DNS可能存在错乱（没错，错乱～，你懂的），所以第一步是要解决DNS能够正确的解析这个问题。方案是：分而治之。国内的DNS让国内的DNS服务器解析。国外的部分需要特别处理，通过端口转发，将DNS交给远方的DNS服务器解析。我们将使用dnsmasq来完成这个功能</p><h3 id="基于-dnsmasq-的方案"><a href="#基于-dnsmasq-的方案" class="headerlink" title="基于 dnsmasq 的方案"></a>基于 dnsmasq 的方案</h3><h4 id="dnsmasq-简介"><a href="#dnsmasq-简介" class="headerlink" title="dnsmasq 简介"></a>dnsmasq 简介</h4><blockquote><p>Dnsmasq是一个开源的轻量级DNS转发和DHCP、TFTP服务器，使用C语言编写。Dnsmasq针对家庭局域网等小型局域网设计，资源占用低，易于配置。</p></blockquote><p>来源：<a href="https://zh.wikipedia.org/wiki/Dnsmasq" target="_blank" rel="noopener">维基百科</a></p><p>使用了openwrt/LDEDE之后将由路由器通过dnsmasq负责提供DHCP服务和DNS服务（通过将DNS服务器IP指向路由器所在的IP来实现）。</p><h4 id="技术方案"><a href="#技术方案" class="headerlink" title="技术方案"></a>技术方案</h4><p>如下图所示，dnsmasq 负责通过查表的方式判断域名是否是国内的域名：</p><ul><li>对于国内的域名直接转发给国内的DNS服务器</li><li>对于国外的域名则转发给本地的<code>5300</code>接口，而<code>5300</code>处有一个进程负责将进来的请求转发给远程的服务器，远程服务器再代理这个请求转发给远程的DNS服务器。</li></ul><p><img src="DNS_flow.png" alt="DNS flow"></p><h3 id="基于-ChinaDNS-的方案"><a href="#基于-ChinaDNS-的方案" class="headerlink" title="基于 ChinaDNS 的方案"></a>基于 ChinaDNS 的方案</h3><h4 id="ChinaDNS-简介"><a href="#ChinaDNS-简介" class="headerlink" title="ChinaDNS 简介"></a>ChinaDNS 简介</h4><p><strong>TODO</strong></p><h4 id="技术方案-1"><a href="#技术方案-1" class="headerlink" title="技术方案"></a>技术方案</h4><p><strong>TODO</strong></p><h3 id="基于无污染DNS服务器的方案"><a href="#基于无污染DNS服务器的方案" class="headerlink" title="基于无污染DNS服务器的方案"></a>基于无污染DNS服务器的方案</h3><p>如果你能找到一个稳定的抗污染的权威的DNS服务器，那么你可以直接使用这个DNS作为你的默认的DNS服务器。这样的DNS服务器是存在的，需要少年你自己去搜索，这里不透露任何消息。</p><h2 id="IP路由技术"><a href="#IP路由技术" class="headerlink" title="IP路由技术"></a>IP路由技术</h2><p>因为IP路由可能存在错乱（没错，错乱～，again），所以对于部分IP是需要特别的路由技术才能顺利访问的。同样的，我们采用分而治之的原则。这里我们使用 iptables 来实现</p><h3 id="基于-iptables-的方案"><a href="#基于-iptables-的方案" class="headerlink" title="基于 iptables 的方案"></a>基于 iptables 的方案</h3><h4 id="iptables-简介"><a href="#iptables-简介" class="headerlink" title="iptables 简介"></a>iptables 简介</h4><blockquote><p>iptables 是一个配置 Linux 内核 防火墙 的命令行工具，是 netfilter 项目的一部分。术语 iptables 也经常代指该内核级防火墙。</p></blockquote><p>来源：<a href="https://wiki.archlinux.org/index.php/Iptables_%28%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87%29" target="_blank" rel="noopener">archlinux wiki</a></p><h4 id="技术方案-2"><a href="#技术方案-2" class="headerlink" title="技术方案"></a>技术方案</h4><p>iptables 将根据配置转发相关的网络请求，实现将国内和国外IP分离的目标。由于 iptables 实在很复杂，配置起来很麻烦，所以我们将通过另一个程序自动帮我们配置。但我们依旧要介绍一个相关的原理。</p><p>如下图所示，iptables 通过查询规则的方式判断IP是否是国外的IP：</p><ul><li>国内的IP直接转发</li><li>国外的IP则转发到本地的 1234 端口，由一个 <a href="#开启透明代理">下文中的进程</a> 转发到远程服务器，再由远程服务器代为发起请求。</li></ul><p><img src="IP_flow.png" alt="IP flow"></p><h4 id="基于-luci-app-shadowsocks-的方案"><a href="#基于-luci-app-shadowsocks-的方案" class="headerlink" title="基于 luci-app-shadowsocks 的方案"></a>基于 luci-app-shadowsocks 的方案</h4><p>因为 iptables 实在比较难配置，而且难以理解，所以如果有程序帮助我们自动配置，那就开心多了，幸运的是 luci-app-shadowsocks 可以帮我们做到。具体的使用方法见下文。</p><h1 id="动手实践"><a href="#动手实践" class="headerlink" title="动手实践"></a>动手实践</h1><h2 id="安装软件"><a href="#安装软件" class="headerlink" title="安装软件"></a>安装软件</h2><p>下面假设你是熟悉 Linux 基本操作的，不做过多的解释。<br>首先我们先更新一下 package 信息<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">opkg update</span><br></pre></td></tr></table></figure></p><h3 id="安装-dnsmasq"><a href="#安装-dnsmasq" class="headerlink" title="安装 dnsmasq"></a>安装 dnsmasq</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">opkg install dnsmasq</span><br></pre></td></tr></table></figure><h3 id="配置-dnsmasq"><a href="#配置-dnsmasq" class="headerlink" title="配置 dnsmasq"></a>配置 dnsmasq</h3><h4 id="新建配置目录"><a href="#新建配置目录" class="headerlink" title="新建配置目录"></a>新建配置目录</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir /etc/dnsmasq.d</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"conf-dir=/etc/dnsmasq.d"</span> &gt;&gt; /etc/dnsmasq.conf</span><br></pre></td></tr></table></figure><h4 id="下载-IP-地址文件"><a href="#下载-IP-地址文件" class="headerlink" title="下载 IP 地址文件"></a>下载 IP 地址文件</h4><p>为了方便起见，我们在路由器上使用 <code>wget</code> 将配置文件下载到路由器。（你也可以在电脑上下载文件，然后上传上来，这样可以避免安装 <code>wget</code>, 节约空间）</p><ul><li><p>首先安装 <code>wget</code>:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">opkg install wget</span><br></pre></td></tr></table></figure></li><li><p>下载文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /etc/dnsmasq.d</span><br><span class="line">wget -4 --no-check-certificate -O /etc/dnsmasq.d/accelerated-domains.china.conf https://github.com/felixonmars/dnsmasq-china-list/raw/master/accelerated-domains.china.conf</span><br><span class="line">wget -4 --no-check-certificate -O /etc/dnsmasq.d/bogus-nxdomain.china.conf https://github.com/felixonmars/dnsmasq-china-list/raw/master/bogus-nxdomain.china.conf</span><br></pre></td></tr></table></figure></li></ul><h4 id="设置非国内域名的-DNS-server"><a href="#设置非国内域名的-DNS-server" class="headerlink" title="设置非国内域名的 DNS server"></a>设置非国内域名的 DNS server</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /etc/dnsmasq.d</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"server=/#/127.0.0.1#5300"</span> &gt; gfwlist.conf</span><br></pre></td></tr></table></figure><h4 id="配置格式说明"><a href="#配置格式说明" class="headerlink" title="配置格式说明"></a>配置格式说明</h4><p><code>accelerated-domains.china.conf</code> 和 <code>bogus-nxdomain.china.conf</code> 内的格式类似于：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">server=/baidu.com/114.114.114.114</span><br></pre></td></tr></table></figure></p><p>意思就是 <code>baidu.com</code> 及其子域名的 DNS 将走 <code>114.114.114.114</code></p><p>在 <code>gfwlist.conf</code> 我们设置了<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">server=/#/127.0.0.1#5300</span><br></pre></td></tr></table></figure></p><p>因为 <code>#</code> 代表所有的域名，而 dnsmasq 的规则是按照准确匹配优先的原则，所以这条规则是其他规则匹配不到的情况下才起作用，也就是匹配国内域名失败的情况下才起作用。而本规则的含义是将 DNS 请求转发到 <code>127.0.0.1</code> 的 <code>5300</code> 端口. <a href="#开启-UDP-relay">下文</a> 我们将启动一个进程来监听这个端口。</p><h3 id="安装-iptables"><a href="#安装-iptables" class="headerlink" title="安装 iptables"></a>安装 iptables</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">opkg install iptables</span><br></pre></td></tr></table></figure><h3 id="安装-shadowsocks-libev-及其依赖"><a href="#安装-shadowsocks-libev-及其依赖" class="headerlink" title="安装 shadowsocks-libev 及其依赖"></a>安装 shadowsocks-libev 及其依赖</h3><p>LEDE自带了 <code>shadowsocks-libev</code>,但是版本太低，会和下面的 <code>luci-app-shadowsocks</code> 发生冲突，因此需要下载最新的版本。</p><h4 id="下载软件包"><a href="#下载软件包" class="headerlink" title="下载软件包"></a>下载软件包</h4><p>前去 <a href="https://github.com/shadowsocks/openwrt-shadowsocks" target="_blank" rel="noopener">官方仓库</a> 下载最新的版本。我们选择下载已经编译好的二进制包，注意选择正确的CPU架构：<code>mips_24kc</code>。</p><p>关于如何查看正确的CPU架构信息，你可以在使用<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">opkg update</span><br></pre></td></tr></table></figure></p><p>的时候观察请求的URL：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Downloading http://downloads.lede-project.org/releases/17.01.4/packages/mips_24kc/base/Packages.gz</span><br></pre></td></tr></table></figure></p><p>可以看出 Netear WNDR4300 的 CPU架构是 <code>mips_24kc</code>。</p><p>相关的依赖的包，也要一并下载回来：</p><ul><li>libcares</li><li>libev</li><li>libmbedtls</li><li>libsodium</li></ul><h4 id="安装依赖"><a href="#安装依赖" class="headerlink" title="安装依赖"></a>安装依赖</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">opkg install &lt;libcares_*_mips_24kc.ipk&gt;</span><br><span class="line">opkg install &lt;libev_*_mips_24kc.ipk&gt;</span><br><span class="line">opkg install &lt;libmbedtls_*_mips_24kc.ipk&gt;</span><br><span class="line">opkg install &lt;libsodium_*_mips_24kc.ipk&gt;</span><br></pre></td></tr></table></figure><h4 id="安装-shadowsocks-libev"><a href="#安装-shadowsocks-libev" class="headerlink" title="安装 shadowsocks-libev"></a>安装 shadowsocks-libev</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">opkg install &lt;shadowsocks-libev_*_mips_24kc.ipk&gt;</span><br></pre></td></tr></table></figure><h3 id="安装-luci-app-shadowsocks-及其依赖"><a href="#安装-luci-app-shadowsocks-及其依赖" class="headerlink" title="安装 luci-app-shadowsocks 及其依赖"></a>安装 luci-app-shadowsocks 及其依赖</h3><h4 id="下载软件包-1"><a href="#下载软件包-1" class="headerlink" title="下载软件包"></a>下载软件包</h4><p>前往<a href="https://github.com/shadowsocks/luci-app-shadowsocks" target="_blank" rel="noopener">官方 GitHub 仓库</a>下载软件包，最要不要下载<code>*-without-ipset-*</code>的包，可能会导致缺少依赖。</p><h4 id="安装依赖-1"><a href="#安装依赖-1" class="headerlink" title="安装依赖"></a>安装依赖</h4><p>透明代理功能需要 <code>iptables-mod-tproxy</code><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">opkg install iptables-mod-tproxy</span><br></pre></td></tr></table></figure></p><h4 id="安装-luci-app-shadowsocks"><a href="#安装-luci-app-shadowsocks" class="headerlink" title="安装 luci-app-shadowsocks"></a>安装 luci-app-shadowsocks</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">opkg install &lt;luci-app-shadowsocks_*_all.ipk&gt;</span><br></pre></td></tr></table></figure><h3 id="配置-shadowsocks"><a href="#配置-shadowsocks" class="headerlink" title="配置 shadowsocks"></a>配置 shadowsocks</h3><h4 id="新增-shadowsocks-服务器"><a href="#新增-shadowsocks-服务器" class="headerlink" title="新增 shadowsocks 服务器"></a>新增 shadowsocks 服务器</h4><p>在 openwrt/LEDE 管理界面的菜单 services -&gt; Shadowsocks 页面的 <code>Servers Manage</code> tab 中,新建你自己的 shadowsocks 服务器, 如下图:</p><p><img src="add_ss_server.png" alt="Add SS server"></p><h4 id="增加白名单"><a href="#增加白名单" class="headerlink" title="增加白名单"></a>增加白名单</h4><p>我们增加一个白名单,里面记录了中国地区的IP,这样 shadowscoks 就能绕过这些IP,不使用代理了。</p><h5 id="下载白名单"><a href="#下载白名单" class="headerlink" title="下载白名单"></a>下载白名单</h5><p>我们将从网上下载一个中国地区的IP列表:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget -O- <span class="string">'http://ftp.apnic.net/apnic/stats/apnic/delegated-apnic-latest'</span> | awk -F\| <span class="string">'/CN\|ipv4/ &#123; printf("%s/%d\n", $4, 32-log($5)/log(2)) &#125;'</span> &gt; /etc/chinadns_chnroute.txt</span><br></pre></td></tr></table></figure></p><p>这个命令主要是去 <a href="https://www.apnic.net/" target="_blank" rel="noopener">APNIC</a> 拿所有的 IP 列表，并过滤出来中国大陆的 IP-CIDR 列表，生成一个文件在 <code>/etc/chinadns_chnroute.txt</code></p><h5 id="应用白名单"><a href="#应用白名单" class="headerlink" title="应用白名单"></a>应用白名单</h5><p>在 openwrt/LEDE 管理界面的菜单 services -&gt; Shadowsocks 页面的 <code>Access Control</code> tab 中, 应用你的配置，如下图：</p><p><img src="white_access_list.png" alt="White Access List"></p><h4 id="开启-UDP-relay"><a href="#开启-UDP-relay" class="headerlink" title="开启 UDP relay"></a>开启 UDP relay</h4><p>我们将开启 UDP relay 将 53 号端口的 DNS 查询请求，经由远程服务器转发至远程DNS服务器，配置如下图：</p><p><img src="port_forward.png" alt="Port Forward"></p><p>这里监听的本地端口是 <code>5300</code> 与 <a href="#配置格式说明">上文中的设定</a> 相一致，使用的远程DNS服务器是 <code>8.8.4.4</code></p><h4 id="开启透明代理"><a href="#开启透明代理" class="headerlink" title="开启透明代理"></a>开启透明代理</h4><p>透明代理启动后将会自动的帮我们配置好 iptables ，这也就是为什么我们不需要亲自配置 iptables 的原因。<br>透明代理的设置需要选择一个配置过的服务器,我们直接选择刚刚配置好的就行了。如下图：</p><p><img src="transparent_proxy.png" alt="transparent proxy"></p><h1 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h1><h2 id="DNS-通过-TCP-发送请求"><a href="#DNS-通过-TCP-发送请求" class="headerlink" title="DNS 通过 TCP 发送请求"></a>DNS 通过 TCP 发送请求</h2><p>因为 DNS 走的是 UDP 协议，很容易被伪造，而且 UDP 本身服务也不可靠。所以让 DNS 解析走 TCP 是一个好方案。DNS 走 TCP 的前提是 DNS 服务器支持 TCP 的方式查询，事实上由于这个是 <a href="https://tools.ietf.org/html/rfc7766" target="_blank" rel="noopener">RFC7766</a> 设定的标准。目前绝大多数 DNS 服务器是支持 TCP 查询。</p><h3 id="DNS-forwarder-方案"><a href="#DNS-forwarder-方案" class="headerlink" title="DNS-forwarder 方案"></a>DNS-forwarder 方案</h3><p><strong>TODO</strong></p><h3 id="DNS2socket-方案"><a href="#DNS2socket-方案" class="headerlink" title="DNS2socket 方案"></a>DNS2socket 方案</h3><p><strong>TODO</strong></p><h2 id="TCP-加速"><a href="#TCP-加速" class="headerlink" title="TCP 加速"></a>TCP 加速</h2><h3 id="kcptun"><a href="#kcptun" class="headerlink" title="kcptun"></a>kcptun</h3><p><strong>TODO</strong></p><h2 id="Linux-BBR"><a href="#Linux-BBR" class="headerlink" title="Linux BBR"></a>Linux BBR</h2><p><strong>TODO</strong></p><h1 id="一键脚本"><a href="#一键脚本" class="headerlink" title="一键脚本"></a>一键脚本</h1><p>作为一个程序员，一切以能够自动化作为自豪，同时也是为了以后折腾挂了，再恢复起来比较方便，这里提供了一键安装的脚本。</p><p><strong>TODO</strong></p><h1 id="NOTE"><a href="#NOTE" class="headerlink" title="NOTE"></a>NOTE</h1><p>很多标记为 <strong>TODO</strong> 的事项，因为本人太忙，可能就不写了，但是我都给出了关键信息，通过自行搜索应该能够找到足够的资料独立完成。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><a href="https://blog.chionlab.moe/2016/01/23/openwrt-bypass-gfw-solution/" target="_blank" rel="noopener">OpenWRT路由器上的ShadowSocks+ChinaDNS搭梯子方案</a></li><li><a href="https://github.com/mba811/openwrt-Ss" target="_blank" rel="noopener">打造一台翻墙路由器</a></li><li><a href="https://imciel.com/2016/01/22/openwrt-shadowsocks/" target="_blank" rel="noopener">我的路由器自动翻墙方案 shadowsocks+dns2socks+pdnsd+dnsmasq</a></li><li><a href="https://softwaredownload.gitbooks.io/openwrt-fanqiang/content/ebook/03.5.html" target="_blank" rel="noopener">配置OpenWrt shadowsocks路由器智能自动翻墙</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;TL;DR&lt;/strong&gt; 本文将介绍自动路由切换技术，这是作为专业的程序狗必备的生产性技能。&lt;br&gt;
    
    </summary>
    
    
      <category term="路由切换技术" scheme="https://blog.xiaoquankong.ai/tags/%E8%B7%AF%E7%94%B1%E5%88%87%E6%8D%A2%E6%8A%80%E6%9C%AF/"/>
    
      <category term="OPENWRT/LEDE" scheme="https://blog.xiaoquankong.ai/tags/OPENWRT-LEDE/"/>
    
  </entry>
  
  <entry>
    <title>Reinforcement Learning: 初次交手，多多指教</title>
    <link href="https://blog.xiaoquankong.ai/Reinforcement-Learning-%E5%88%9D%E6%AC%A1%E4%BA%A4%E6%89%8B%EF%BC%8C%E5%A4%9A%E5%A4%9A%E6%8C%87%E6%95%99/"/>
    <id>https://blog.xiaoquankong.ai/Reinforcement-Learning-初次交手，多多指教/</id>
    <published>2017-11-24T06:46:15.000Z</published>
    <updated>2018-08-13T11:08:02.489Z</updated>
    
    <content type="html"><![CDATA[<p><strong>TL;DR</strong> 图形游戏（比如坦克大战）如果要实现智能Agent（AKA 电脑玩家）的话，目前最佳的方案就是Reinforcement Learning (简称 RL ;中文：增强学习)。 本文记录了我和Reinforcement Learning的第一次交手，将带你了解这位名扬四海却又神秘莫测的对手。:)<br><a id="more"></a></p><h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>公司举办Hackthon（中国：黑客松 &lt;- 来自维基百科的翻译），其中有一道题是实现坦克大战的玩家程序。在别人普遍使用人工策略的情况下，考虑到我们团队人少（精确的讲只有我一人会写程序，其他团队起码三个程序员），所以在人工策略这条路上肯定是非常的吃亏，所以不如另辟蹊径，拼搏一把（反正也基本出不了初赛了)。于是我们选择了让机器学习的方案。于是 就成了目标。在此之前，我也只是听过RL的大名，现在要使用RL，内心是既兴奋又紧张。</p><h1 id="Reinforcement-Learning"><a href="#Reinforcement-Learning" class="headerlink" title="Reinforcement Learning"></a>Reinforcement Learning</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>为了更加容易理解，我们将引入坦克大战的例子来辅助讲解。总的来说RL模型将现实世界的问题抽象成两类对象的交互：<code>Enviroment</code>和<code>Agent</code>，对坦克大战而言，游戏就是<code>Enviroment</code>，而游戏玩家就是<code>Agent</code>。</p><p><code>Enviroment</code>提供<code>observation</code>：这是<code>Agent</code>对外界环境的观察，坦克大战中，游戏的图形界面就是<code>Agent</code>(游戏玩家)对<code>Enviroment</code>（游戏）的<code>observation</code>。<code>Agent</code>使用自己的逻辑，根据对<code>observation</code>的理解，给出一个<code>action</code>：这表示对外界环境的一个操作或者反馈，坦克大战中游戏玩家的操作就是<code>action</code>。<code>action</code>在每个step中会被发送给<code>Enviroment</code>,<code>Environment</code>则会返回新的<code>observation</code>和<code>reward</code>。<code>reward</code>表示的是当前情况下<code>Environment</code>对<code>aciton</code>的反馈：数值可能正数也可能负数也可能是零，坦克大战中坦克被击毁、击毁敌方坦克、获取装备或者旗帜等直接得分或者失分都算是<code>reward</code>。然后<code>Agent</code>根据新的<code>observation</code>给出新的<code>action</code>,如此循环往复。聪明的算法能在<code>observation</code>、<code>action</code>和<code>reward</code>中发现关系，使得每一次给出的<code>action</code>都能得到最大期望的<code>reward</code>。</p><p><img src="RL_loop.svg" alt="Reinforcement Learning Loop"></p><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><p>与Supervised Learning不同的是，Reinforcement Learning要解决的问题是存在<code>reward delay</code>现象的，也就是说Reinforcement Learning会考虑全局最优，而不是当前这一步是最优的，避免“赢了战役，输了战争”这种现象。坦克大战中的例子就是高级玩家可能会选择一种策略：即使不停的被攻击，他的坦克不选择躲避炮弹而是选择承受炮火的同时持续不断的攻击你的基地的外墙。只看一步操作而言，这样的行动是失败的，因为己方的某一辆坦克被击毁，但从长远的角度来看，你能在最后一辆己方坦克被击毁前成功的击毁对方的基地。</p><h2 id="Q-learning-算法"><a href="#Q-learning-算法" class="headerlink" title="Q-learning 算法"></a>Q-learning 算法</h2><p>我们将介绍Reinforcement Learning中比较容易理解的算法：Q-learning</p><h3 id="Q-learning-简介"><a href="#Q-learning-简介" class="headerlink" title="Q-learning 简介"></a>Q-learning 简介</h3><p><strong>TODO</strong></p><h3 id="实验环境"><a href="#实验环境" class="headerlink" title="实验环境"></a>实验环境</h3><p>我们将引入一个简单的环境：一个房子。这个房子由5个房间构成（编号：0 - 4），连上房子外的空间（编号：5），共六个状态。房间之间与房间和户外空间之间可能存在门，也就是相互联通。如下图所示：</p><p><img src="house_environment.gif" alt="House environment"></p><p>我们根据房间的联通状态，将上述的物理房间图抽象，将每个房间抽象成一个节点(Node)或者状态（state),房子之间存在联通关系的则用一个有向边表示（因为房门是双向联通，所以每个房门对应两个相向的有向边），如下图所示：</p><p><img src="node_environment.gif" alt="Node environment"></p><p>在这个例子中，我们的目标是将 agent （抽象概念） 从房间里移动到户外空间。Q-learning 的目标是到达 reward 最高的状态，而在本例中，状态 5 就是我们想要的目标状态（也称最终状态），Q-learning 到达目标状态后就会永久留在目标状态，因此我们给状态 5 增加一个指向自己的有向边（如上图示）。这种目标或者状态称之为 absorbing goal 或者 absorbing state。</p><p>为了让状态 5 成为目标状态，我们将所有指向状态 5 的有向边全部赋值 reward=100 ，除此之外的边全部赋值 reward=0 。如下图所示：</p><p><img src="node_environment_with_reward.gif" alt="Node environment with reward"></p><p>假设本例子中的 agent 是一个笨笨的虚拟机器人，它会从以前的经验中学习知识，它能够从一个房间到另一个房间，但它不知道房间的情况也不知道从房间到外面空间的路径。</p><p>假设本例子的目标是建立一个模型帮助 agent 从房子中的 <strong>任意一个房间</strong> 出发到达户外空间。现在我们假设 agent 在房间 2 ，我们想要让它学习如何到达户外空间。如下图所示：</p><p><img src="agent_at_room_2.gif" alt="Agent at room 2"></p><p>为了和 Reinforcement Learning 保持一支，我们特别将每个房间 Node 称之状态（state）或者叫做 observation ，而将 agent 的每一次移动称之为 action。observation 在这里有点难以理解，所以这里使用 状态（state）这个 Q-learning 术语。在本例子中，action 使用有向边来表示。如下图所示：</p><p><img src="agent_at_state_2.gif" alt="agent at state 2"></p><p>从状态 2 agent 可以到达状态 3，这是因为状态 2 存在到状态 3 的有向边，也就是存在联通的门。状态 2 不能直接到达状态 1，这是因为状态 2 不存在到达状态 1 的有向边，也就是这两个房间之间不存在门。状态 3 可以到达状态 1 、状态 4 和回到状态 2。agent 在状态 1 和状态 0 的可能到达状态，读者可以自行观察，不再赘述。我们将上述所有可能状态、 action 和 reward 编制成一张表：得到 matrix R。如下图所示。</p><p> <img src="matrix_r_init.gif" alt="matrix r init"></p><p> <strong>NOTE</strong> 表中的 -1 表示无效值，也就是这个 action 不存在，比如不存在从状态 0 到状态 1 的 action 或者说门。</p><p> 我们将增加一个相似的矩阵 matrix Q ，用于表示 agent 从中学习的知识。matrix Q 的每一个行代表一个前一个状态，每一列表示下一个状态。刚开始时，agent 并没有学习到任何知识，所以 matrix Q 中的值初始化为 0. 在本例子中，我们已经知道所有的状态数为 6， 在现实例子中，这个数可能是未知的，所以初始化的时候可能只有一行一列，当发现新的状态时，Matrix Q 可以增加新的行和列。</p><p> Q-learning 的状态转移规则如下：</p><p> $$ Q(state, action) = R(state, action) + \gamma * Max[Q(next state, all actions)] $$</p><p> 按照这个公式，赋值Q中一个元素的值等于 Matrix R 中的相应的值和 $\gamma$ (学习参数) 乘以 下一个状态中所有的action的最大的 Q reward。</p><p> 我们的 agent 不需要老师就能从经验中学习，因此这个是 非监督学习。每一次 agent 从一个状态转到另一个状态，最终达到目标状态。这样的一次探索过程我们称之为 episode。每一个 episode 包含了 agent 从初始状态到目标状态的所有的 action。每当 agent 到达目标状态时，我们就开始下一个 episode。</p><p>Q-Learning 算法大体运行如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Set the gamma parameter, and environment rewards in matrix R.</span><br><span class="line">Initialize matrix Q to zero.</span><br><span class="line">For each episode &#123;</span><br><span class="line">  Select a random initial state.</span><br><span class="line">  Do While the goal state hasn&apos;t been reached. &#123;</span><br><span class="line">      Select one among all possible actions for the current state.</span><br><span class="line">      Using this possible action, consider going to the next state.</span><br><span class="line">      Get maximum Q value for this next state based on all possible actions.</span><br><span class="line">      Compute: Q(state, action) = R(state, action) + Gamma * Max[Q(next state, all actions)]</span><br><span class="line">      Set the next state as the current state.</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;TL;DR&lt;/strong&gt; 图形游戏（比如坦克大战）如果要实现智能Agent（AKA 电脑玩家）的话，目前最佳的方案就是Reinforcement Learning (简称 RL ;中文：增强学习)。 本文记录了我和Reinforcement Learning的第一次交手，将带你了解这位名扬四海却又神秘莫测的对手。:)&lt;br&gt;
    
    </summary>
    
    
      <category term="机器学习" scheme="https://blog.xiaoquankong.ai/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="Reinforcement_Learning" scheme="https://blog.xiaoquankong.ai/tags/Reinforcement-Learning/"/>
    
      <category term="坦克大战" scheme="https://blog.xiaoquankong.ai/tags/%E5%9D%A6%E5%85%8B%E5%A4%A7%E6%88%98/"/>
    
  </entry>
  
  <entry>
    <title>Netgear WNDR4300固件刷openwrt/LEDE</title>
    <link href="https://blog.xiaoquankong.ai/Netgear-WNDR4300%E5%9B%BA%E4%BB%B6%E5%88%B7openwrt-LEDE/"/>
    <id>https://blog.xiaoquankong.ai/Netgear-WNDR4300固件刷openwrt-LEDE/</id>
    <published>2017-11-19T16:22:48.000Z</published>
    <updated>2018-08-13T11:08:02.483Z</updated>
    
    <content type="html"><![CDATA[<p><strong>TL;DR</strong> Netgear WNDR4300 (v1) 是最经典的能刷openwrt及其分支的路由器，属于性价比比较好的那种。本文将介绍如何使用TFTP刷固件：特别适合于刷机失败了，连不上路由器，想要重新刷的情况。当然也可以用于第一次刷机。<br><a id="more"></a></p><p>之所以选择使用TFTP刷机方式，是因为这种刷机方式非常靠谱，无论你怎么把你的路由器折腾挂的：网连不上/ping不通都是可以使用的，你可以认为这个是刷机方案中的终极武器也是最后方案。</p><h1 id="准备材料"><a href="#准备材料" class="headerlink" title="准备材料"></a>准备材料</h1><p>首先你得需要一个openwrt/LEDE的启动镜像，这里推荐你使用官方的镜像，不要使用各种修改版本或者个人制作的镜像：不安全。官方镜像下载的地址如下：<a href="https://wiki.openwrt.org/toh/start" target="_blank" rel="noopener">openwrt</a>,<a href="https://lede-project.org/toh/views/toh_fwdownload" target="_blank" rel="noopener">LEDE</a>,进去之后寻找你自己的设备，并下载相关的factory镜像和sysupgrade镜像）。个人推荐LEDE，有大量正统的openwrt开发者参与。</p><h1 id="Recovery-mode"><a href="#Recovery-mode" class="headerlink" title="Recovery mode"></a>Recovery mode</h1><p>无论你的路由器挂成什么样了，都能恢复到工厂设置（Factory settings）。</p><ul><li>关闭路由器电源</li><li>用牙签等按住”Reset”键不放</li><li>接通电源，等待指示灯从黄灯-&gt;黄灯闪烁-&gt;绿灯-&gt;绿灯闪烁</li><li>松开”Reset”键</li></ul><h1 id="安装TFTP"><a href="#安装TFTP" class="headerlink" title="安装TFTP"></a>安装TFTP</h1><p>这个根据各个发行版自行安装就可以了。</p><h1 id="设置客户端"><a href="#设置客户端" class="headerlink" title="设置客户端"></a>设置客户端</h1><p>这时的路由器并没有开始DHCP服务，所以需要用户手动设置客户端的IP配置。</p><ul><li>IP地址：192.168.1.2 - 192.168.1.244 任选一个，一般选择192.168.1.2</li><li>网络掩码Mask：255.255.255.0</li><li>Gateway：192.168.1.1</li></ul><h1 id="使用FTP"><a href="#使用FTP" class="headerlink" title="使用FTP"></a>使用FTP</h1><p>我使用的是Linux TFTP，使用过程中遇到一个坑：你直接使用默认的TFTP设置上传镜像是会提示<code>Transfer timeouted</code>错误。我以为我的路由器彻底成砖头了，或者是我的网络设置有问题。后来发现Linux的TFTP需要改成<code>binary</code>模式才能正常上传。</p><h2 id="连接TFTP"><a href="#连接TFTP" class="headerlink" title="连接TFTP"></a>连接TFTP</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tftp 192.168.1.1</span><br></pre></td></tr></table></figure><p>这样就会进入TFTP模式，你会看到命令提示行变成了<code>tftp&gt;</code></p><h2 id="设置binary"><a href="#设置binary" class="headerlink" title="设置binary"></a>设置binary</h2><p>设定传输模式<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tftp&gt; binary</span><br></pre></td></tr></table></figure></p><h2 id="设置详细模式（可选）"><a href="#设置详细模式（可选）" class="headerlink" title="设置详细模式（可选）"></a>设置详细模式（可选）</h2><p>设定详细模式，这样你能看到更多详细的输出<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tftp&gt; verbose</span><br></pre></td></tr></table></figure></p><h2 id="上传image"><a href="#上传image" class="headerlink" title="上传image"></a>上传image</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tftp&gt; put &lt;openwrt_or_lede_factory_image&gt;</span><br></pre></td></tr></table></figure><p>注意这里使用的是factory镜像，不是sysupgrade镜像。另外最好不要修改image的名字，请使用官方下载时的名字，否则可能会造成无法识别的情况</p><h1 id="重启路由"><a href="#重启路由" class="headerlink" title="重启路由"></a>重启路由</h1><p>上传成功后（保险起见，稍等一分钟左右），重启服务器，即可用有线网络连接路由器。注意这个时候路由器的无线网络可能是没有打开的（因为我记不得这个细节了），无线可能找不到网络（如果能找到，那么无线网络的名字很有可能是LEDE），保险起见还是使用有线来连接服务器。连接后，注意你需要修改路由器密码和配置无线网络设置。<strong>最重要的是：默认情况下，即使你需改了无线网络的配置，但路由器的无线网络是没有打开的，你需要按下路由器的硬件上的一个有WI-FI标识的按钮，就可以访问无线路由器了。如果你不知道这个事情，你可能会认为你的路由器坏了，因为你搜索不到无线信号！</strong></p><h1 id="升级系统"><a href="#升级系统" class="headerlink" title="升级系统"></a>升级系统</h1><p>进入管理网页界面后，选择系统，然后选择上传镜像升级。注意这里使用的是sysupgrade镜像（不是factory镜像），最好不要修改镜像的文件名。等待系统重启，大功告成！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;TL;DR&lt;/strong&gt; Netgear WNDR4300 (v1) 是最经典的能刷openwrt及其分支的路由器，属于性价比比较好的那种。本文将介绍如何使用TFTP刷固件：特别适合于刷机失败了，连不上路由器，想要重新刷的情况。当然也可以用于第一次刷机。&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>浏览器中立计划</title>
    <link href="https://blog.xiaoquankong.ai/%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E7%AB%8B%E8%AE%A1%E5%88%92/"/>
    <id>https://blog.xiaoquankong.ai/浏览器中立计划/</id>
    <published>2017-11-18T12:39:00.000Z</published>
    <updated>2018-08-13T11:08:02.500Z</updated>
    
    <content type="html"><![CDATA[<p><strong>TL;DR</strong> 作为Firefox曾经的老用户，很早就使用了Firefox。后来因为Google Chrome浏览器的崛起，切换到了Chrome平台(没错，Chrome不仅仅是一个浏览器，还是一个平台)。但最近Firefox 57发布，做了诸多改进，速度比Chrome更快，作为Firefox的曾经的拥趸，我想切换成Firefox + Chrome的模式，但是很快我发现这个切换成本比想象中的大，因为Chrome浏览器上面的书签、浏览记录和网站密码很难同步到Firefox，反之亦然。于是我开始了浏览器中立计划: 如何做到自己独立于浏览器，不受被特定浏览器的特性捆绑。<br><a id="more"></a></p><h1 id="Firefox-57"><a href="#Firefox-57" class="headerlink" title="Firefox 57"></a>Firefox 57</h1><p><img src="firefox_57.png" alt="Firefox 57"></p><h2 id="发布"><a href="#发布" class="headerlink" title="发布"></a>发布</h2><p>2017年11月14日，Firefox 57正式对外发布，官方的介绍(地址在<a href="https://blog.mozilla.org/blog/2017/11/14/introducing-firefox-quantum/" target="_blank" rel="noopener">这里</a>)是这样说的：</p><blockquote><p>It’s fast. Really fast. Firefox Quantum is over twice as fast as Firefox from 6 months ago, built on a completely overhauled core engine with brand new technology stolen from our advanced research group, and graced with a beautiful new look designed to get out of the way and let you do what you do best: surf a ton of pages, open a zillion tabs, all guilt free because Firefox Quantum uses less memory than the competition. computer will thank you.  🙂</p></blockquote><p>纵览Firefox 57的发布说明，可以总结成：Firefox 57使用了全新技术的CSS渲染引擎，使用了现代CPU的多核和低功耗的特性，速度更快。更改了UI，让界面更好看。同时更改了扩展的机制，废弃了除 WebExtensions 以外的所有扩展机制。</p><h2 id="使用评价"><a href="#使用评价" class="headerlink" title="使用评价"></a>使用评价</h2><p>总的来说，Firefox感官上确实非常快。据官方自己的说法：开非常多的tab也不会卡，这个在Chrome里面很明显，使用过Chrome的小伙伴都知道，Chrome的tab开太多后，浏览器和系统都非常卡。但是Firefox的扩展机制缩小后，很多插件都不能用了，这个比较麻烦。</p><h1 id="浏览器中立计划"><a href="#浏览器中立计划" class="headerlink" title="浏览器中立计划"></a>浏览器中立计划</h1><p>这里我想切换成Firefox + Chrome的模式，但我发现切换成本很大：Chrome的书签、浏览记录和网站密码很难同步到Firefox，反之亦然。于是我开始了浏览器中立计划: 让这些信息脱离浏览器的绑定。</p><h2 id="书签同步"><a href="#书签同步" class="headerlink" title="书签同步"></a>书签同步</h2><p>本来以为Firefox下会有谷歌书签的插件的，后来发现完全没有，我想这应该是因为Google没有开放API的问题吧（Google没有以前那么开放了，sad）。经过调研以后，发现有个Xmarks的服务可以提供跨浏览器的第三方书签服务。Xmarks现在已经是Lastpass旗下的产品了。唯一要注意的是Chrome浏览器版的Xmarks在自动同步上面和Chrome自带的自动同步有些冲突，可能会导致账号不停的退出然后要求登陆，解决方案就是按照Xmarks的提示：先关掉Xmarks的自动同步，再登陆账号。</p><p><img src="xmarks.png" alt="xmarks"></p><h2 id="密码同步"><a href="#密码同步" class="headerlink" title="密码同步"></a>密码同步</h2><p>浏览器给我带来的最大的便利就是可以记住各种各样网站的密码，现在的网站那么多，密码管理起来很麻烦。幸运的是有不少不错的密码类管理服务：<a href="https://lastpass.com/" target="_blank" rel="noopener">Lastpass</a>, <a href="https://1password.com/" target="_blank" rel="noopener">1Password</a>, or <a href="https://keepersecurity.com/" target="_blank" rel="noopener">Keeper</a> （这个名单是Github在保存Two-factor recovery codes时推荐的列表）。最终我选择了比较常见的Lastpass，当然也是因为Xmarks也是Lastpass旗下的产品，本来以为可以使用一个账号登陆呢，结果不行，很失望。使用这类密码类管理服务的好处就是它不仅能够保存网站密码，还能保存SSH key等纯文本的密钥，还能用来保存二进制的文件。</p><p><img src="LastPass-Logo-Color.png" alt="LastPass"></p><h2 id="浏览记录同步"><a href="#浏览记录同步" class="headerlink" title="浏览记录同步"></a>浏览记录同步</h2><p>暂时无解，只能使用各自的账号体系同步：Chrome使用谷歌账号，Firefox使用Firefox的账号体系。幸运的是浏览记录同步不是那么重要的功能，当然也许以后有大神或者公司可以开发类似的服务，那么整个浏览器中立计划也就完备了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;TL;DR&lt;/strong&gt; 作为Firefox曾经的老用户，很早就使用了Firefox。后来因为Google Chrome浏览器的崛起，切换到了Chrome平台(没错，Chrome不仅仅是一个浏览器，还是一个平台)。但最近Firefox 57发布，做了诸多改进，速度比Chrome更快，作为Firefox的曾经的拥趸，我想切换成Firefox + Chrome的模式，但是很快我发现这个切换成本比想象中的大，因为Chrome浏览器上面的书签、浏览记录和网站密码很难同步到Firefox，反之亦然。于是我开始了浏览器中立计划: 如何做到自己独立于浏览器，不受被特定浏览器的特性捆绑。&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Python bisect模块的妙用</title>
    <link href="https://blog.xiaoquankong.ai/Python-bisect%E6%A8%A1%E5%9D%97%E7%9A%84%E5%A6%99%E7%94%A8/"/>
    <id>https://blog.xiaoquankong.ai/Python-bisect模块的妙用/</id>
    <published>2017-11-17T10:57:39.000Z</published>
    <updated>2018-08-13T11:08:02.489Z</updated>
    
    <content type="html"><![CDATA[<p><strong>TL;DR</strong> 本文将介绍Python bisect模块在某些场景下的妙用，可以高效和优雅的改善原有使用if-else才能解决问题。<br><a id="more"></a></p><h1 id="难题：查询整数所属的区间"><a href="#难题：查询整数所属的区间" class="headerlink" title="难题：查询整数所属的区间"></a>难题：查询整数所属的区间</h1><p>应用开发过程中，经常出现一种情景，需要你查询一个整数落在哪一个范围内，比如根据消费金额确定优惠金额或者打折力度等。具体的例子有：消费满100元优惠10元，消费满200元优惠25元，等等。</p><h2 id="常规解决方案及其缺点"><a href="#常规解决方案及其缺点" class="headerlink" title="常规解决方案及其缺点"></a>常规解决方案及其缺点</h2><p>通常情况下，都是使用switch／if-elif来解决的，范围比较少的情况，代码还属于比较简洁的，当范围的数量增加，代码就变的相当的不简洁了，正如下面的代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">discount = <span class="keyword">None</span></span><br><span class="line"><span class="keyword">if</span> value &lt; <span class="number">100</span>:</span><br><span class="line">discount = <span class="number">0</span></span><br><span class="line"><span class="keyword">elif</span> value &lt; <span class="number">200</span>:</span><br><span class="line">discount = <span class="number">10</span></span><br><span class="line"><span class="keyword">elif</span> values &lt; <span class="number">300</span>:</span><br><span class="line">discount = <span class="number">25</span></span><br><span class="line"><span class="keyword">elif</span> values &lt; <span class="number">400</span>:</span><br><span class="line">discount = <span class="number">42</span></span><br><span class="line"><span class="keyword">elif</span> values &lt; <span class="number">500</span>:</span><br><span class="line">discount = <span class="number">53</span></span><br><span class="line"><span class="keyword">elif</span> values &lt; <span class="number">600</span>:</span><br><span class="line">discount = <span class="number">64</span></span><br><span class="line"><span class="keyword">elif</span> values &lt; <span class="number">700</span>:</span><br><span class="line">discount = <span class="number">75</span></span><br><span class="line"><span class="keyword">elif</span> values &lt; <span class="number">800</span>:</span><br><span class="line">discount = <span class="number">86</span></span><br><span class="line"><span class="keyword">elif</span> values &lt; <span class="number">900</span>:</span><br><span class="line">discount = <span class="number">97</span></span><br><span class="line"><span class="keyword">elif</span> values &lt; <span class="number">1000</span>:</span><br><span class="line">discount = <span class="number">108</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">discount = <span class="number">120</span></span><br></pre></td></tr></table></figure><h2 id="基于bisect的方案"><a href="#基于bisect的方案" class="headerlink" title="基于bisect的方案"></a>基于bisect的方案</h2><h3 id="bisect介绍"><a href="#bisect介绍" class="headerlink" title="bisect介绍"></a>bisect介绍</h3><p>bisect是python的标准模块，是一个关于数组二分查找法的库，里面提供了在这里非常有用的三个函数<code>bisect_left</code>, <code>bisect_right</code>, <code>bisect</code>. 这三个参数都接受一个array和一个数字，返回将数字插入这个array后这个数字的位置（index），但并不真正执行插入操作。比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">In[0]: import bisect</span><br><span class="line">In[1]: bisect.bisect([1, 3, 5], 2)</span><br><span class="line">Out[1]:</span><br><span class="line">1</span><br></pre></td></tr></table></figure><p>表示如果将2插入1 3 5中间，那么插进去之后的index则为返回值（本例，返回值为1），如果出现相同的值，<code>bisect()</code>函数选择将值插在后面也就是原有值的右侧：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">In[<span class="number">0</span>]: <span class="keyword">import</span> bisect</span><br><span class="line">In[<span class="number">1</span>]: bisect.bisect([<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>], <span class="number">3</span>)</span><br><span class="line">Out[<span class="number">1</span>]:</span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure><p><code>bisect_left()</code>函数选择将值插在前面也就是原有值的左侧：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">In[<span class="number">0</span>]: <span class="keyword">import</span> bisect</span><br><span class="line">In[<span class="number">1</span>]: bisect.bisect_left([<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>], <span class="number">3</span>)</span><br><span class="line">Out[<span class="number">1</span>]:</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure><p>另外<code>bisect_right()</code>函数是<code>bisect()</code>函数的别名，或者反之。</p><h3 id="利用bisect查找整数范围"><a href="#利用bisect查找整数范围" class="headerlink" title="利用bisect查找整数范围"></a>利用bisect查找整数范围</h3><p>bisect函数是二分查找，既可以用来插入，当然也可以用来检索信息，比如查找值所属的区段／区间。</p><p>前面我们提到的那个函数就可以利用bisect做改写:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">mapping = &#123;</span><br><span class="line"><span class="number">0</span>: <span class="number">0</span>,</span><br><span class="line"><span class="number">1</span>:<span class="number">10</span>,</span><br><span class="line"><span class="number">2</span>: <span class="number">25</span>,</span><br><span class="line"><span class="number">3</span>: <span class="number">42</span>,</span><br><span class="line"><span class="number">4</span>: <span class="number">53</span>,</span><br><span class="line"><span class="number">5</span>: <span class="number">64</span>,</span><br><span class="line"><span class="number">6</span>: <span class="number">75</span>,</span><br><span class="line"><span class="number">7</span>: <span class="number">86</span>,</span><br><span class="line"><span class="number">8</span>: <span class="number">97</span>,</span><br><span class="line"><span class="number">9</span>: <span class="number">108</span>,</span><br><span class="line"><span class="number">10</span>: <span class="number">120</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">i = bisect(range(<span class="number">100</span>, <span class="number">1001</span>, <span class="number">100</span>), value)</span><br><span class="line">discount = mapping[i]</span><br></pre></td></tr></table></figure><p>这种方案在业务方案多变，查询范围特别多的情况下具备极大的可维护性和性能优势。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;TL;DR&lt;/strong&gt; 本文将介绍Python bisect模块在某些场景下的妙用，可以高效和优雅的改善原有使用if-else才能解决问题。&lt;br&gt;
    
    </summary>
    
    
      <category term="Python" scheme="https://blog.xiaoquankong.ai/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>理解LSTM的工作原理</title>
    <link href="https://blog.xiaoquankong.ai/%E7%90%86%E8%A7%A3LSTM%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/"/>
    <id>https://blog.xiaoquankong.ai/理解LSTM的工作原理/</id>
    <published>2017-11-16T13:45:58.000Z</published>
    <updated>2018-08-13T11:08:02.506Z</updated>
    
    <content type="html"><![CDATA[<p><strong>TL:DR</strong> 本文属于入门级课程101，用图文并茂的方式详细的介绍了LSTM的工作原理。<br><a id="more"></a></p><h1 id="神经网络"><a href="#神经网络" class="headerlink" title="神经网络"></a>神经网络</h1><p>本文假设你已经了解最基本的神经网络的知识，为了更好的理解本文内容，本文先简单回顾一下神经网络的一些重要的术语和符号，这些符号将在后续的内容中持续使用。</p><h2 id="矩阵表示下的神经网络"><a href="#矩阵表示下的神经网络" class="headerlink" title="矩阵表示下的神经网络"></a>矩阵表示下的神经网络</h2><p>假设：</p><ul><li>$x$是input layer的值</li><li>$W$是hidden layer的权重</li><li>$h$是hidden layer的输出值</li><li>$V$是hidden layer到output layer的权重</li><li>$y$是output layer的值</li><li>$\phi$是激活函数，常见激活函数与特性请见<a href="/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E9%87%8C%E7%9A%84%E6%BF%80%E6%B4%BB%E5%87%BD%E6%95%B0/">神经网络里的激活函数</a>, 这里使用$\sigma$表示sigmoid函数</li><li>$[x,y]$表示两个列向量，在列的维度上concatenate</li></ul><p>则有：</p><p>$$ h = \phi (Wx) $$</p><p>$$ y = Vh $$</p><p>下面是大意图：</p><p><img src="pictorial_view_of_nn.png" alt="pictorial view of NN"><br><strong>TODO: 替换本图</strong></p><h1 id="RNN"><a href="#RNN" class="headerlink" title="RNN"></a>RNN</h1><h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><p>现实生活中很多事情都是序列的，后面的事情和前面是存在上下文关系的，单从一个片段是无法做出判断的。比如：你向上扔一个苹果，在任意时刻，你只能得到一个苹果的瞬时照片，单从照片你根本没法正确推测这个苹果的运动状态的，成功的推测苹果的运动状态，需要模型具备记忆能力能够记住之前苹果的位置信息。传统的神经网络只能判断一个瞬间状态的情况，不具备这种记忆的能力，因此在很多复杂的场景中无法适用。为此人们提出了RNN（Recurrent Neural Network)通过将上一个场景的信息引入下一个场景的方式来记住重要信息。</p><h2 id="RNN原理"><a href="#RNN原理" class="headerlink" title="RNN原理"></a>RNN原理</h2><p>既然上一个场景的hidden layer的值中包含了场景信息，那么理所当然的我们认为hidden layer中包含了有用的上下文知识。所以RNN就是在当前的预测中引入上一个场景的hidden layer值：</p><p>$$ h_t = \phi (W x_t + U h_{t-1}) $$</p><p>$$ y_t = V h_t $$</p><p>其中：</p><ul><li>$h_t$是$t$时刻的hidden layer的值</li><li>$h_{t-1}$是$t-1$时刻（亦即上一个时刻）的hidden layer的值</li></ul><h2 id="缺陷"><a href="#缺陷" class="headerlink" title="缺陷"></a>缺陷</h2><p>尽管RNN成功记忆了部分上下文信息，但存在一个很大的缺陷，那就是它很难记住长期的记忆。还是上面抛苹果的例子，RNN能够记住短期的上下文，所以在后期它能够识别出苹果在加速下落，但是由于没有记住比较久远的苹果先是上升的这个信息，因此RNN只能识别出这个苹果是下降的。</p><h1 id="LSTM"><a href="#LSTM" class="headerlink" title="LSTM"></a>LSTM</h1><p>为了解决这个问题，人们提出了LSTM（Long Short-Term Memory）网络，LSTM最大的特点就是能够记住长期记忆。是目前工业界和学术界最重要的RNN实现。</p><h2 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h2><p>LSTM有两个重要的state或者memory：</p><ul><li>长期记忆 (long-term memory: $lsm$, 通常被称为<code>cell state</code>, 标识为$C$)</li><li>工作记忆 (working memory: $wm$, 通常被称为<code>hidden state</code>, 标识为$h$)。</li></ul><p>一个学习迭代有一下几个部分：</p><ul><li>选择性遗忘部分长期记忆：将记忆中不需要的记忆移除</li><li>将现有的一些信息加入到长期记忆中<ul><li>计算候选长期记忆</li><li>选择函数</li></ul></li><li>从long-term memory中提取working memory<ul><li>计算候选的working memory</li><li>选择函数</li></ul></li></ul><h3 id="选择性遗忘部分长期记忆"><a href="#选择性遗忘部分长期记忆" class="headerlink" title="选择性遗忘部分长期记忆"></a>选择性遗忘部分长期记忆</h3><p>这个部分也称之为<code>forget gate layer</code></p><h4 id="遗忘函数-遗忘门-forget-gate"><a href="#遗忘函数-遗忘门-forget-gate" class="headerlink" title="遗忘函数/遗忘门(forget gate)"></a>遗忘函数/遗忘门(forget gate)</h4><p>我们先决定哪些长期记忆需要被遗忘（或者保留）。我们使用一个单独的浅层神经网络来学习。在$t$时刻：</p><p>$$ remember_t = \sigma (W_r x_t + U_r wm_{t-1}) $$</p><p>这里的$remember_t$是一个boolean序列，长度和$lsm_{t-1}$相同，通常被称为<code>forget gate</code>。值<code>1</code>表示保留$lsm_{t-1}$对应位置的数值，<code>0</code>则表示抛弃或者删除。</p><p>上述公式还可以表示成：</p><p>$$ f_t = \sigma (W_f \cdot [ h_{t-1} , x_t ] + b_f) $$</p><p><img src="forget_func.png" alt="forget function"></p><h4 id="保存下来的长期记忆"><a href="#保存下来的长期记忆" class="headerlink" title="保存下来的长期记忆"></a>保存下来的长期记忆</h4><p>有了遗忘函数后，我们就能确定保存下来的长期记忆是什么了。在$t$时刻：</p><p>$$ olsm_t = forget_t \odot lsm_{t-1} $$</p><h3 id="增加新的长期记忆"><a href="#增加新的长期记忆" class="headerlink" title="增加新的长期记忆"></a>增加新的长期记忆</h3><p>除了有些某些老的记忆需要继续保留，我们需要把当前的一些重要信息添加到长期记忆中。</p><h4 id="计算候选的长期记忆"><a href="#计算候选的长期记忆" class="headerlink" title="计算候选的长期记忆"></a>计算候选的长期记忆</h4><p>首先算出来全体候选记忆。在$t$时刻：</p><p>$$ lsm’_t = \phi (W_l x_t + U_l wm_{t-1}) $$</p><p>这里的$lsm’_t$代表可能加入长期记忆的记忆序列，长度和$lsm_{t-1}$相同。这里的$\phi$函数常常选择$tanh$函数。</p><p>上述公式还可以表示成：<br>$$ \tilde{C}_t = \phi (W_C \cdot [ h_{t-1} , x_t ] + b_C) $$</p><h4 id="选择函数"><a href="#选择函数" class="headerlink" title="选择函数"></a>选择函数</h4><p>有了候选记忆后，需要一个选择函数负责实际选择哪些记忆可以加入长期记忆。在$t$时刻：</p><p>$$ save_t = \phi (W_s x_t + U_s wm_{t-1}) $$</p><p>上述公式还可以表示成：<br>$$ i_t = \sigma (W_i \cdot [h_{t-1},x_t] + b_i) $$</p><h4 id="新的长期记忆"><a href="#新的长期记忆" class="headerlink" title="新的长期记忆"></a>新的长期记忆</h4><p>有了候选的长期记忆和选择函数后，我们就可以确定哪些记忆是要添加到长期记忆的。在$t$时刻：</p><p>$$ nlsm_t = save_t \odot lsm’_t $$</p><p><img src="input_func.png" alt="input function"></p><h3 id="更新长期记忆"><a href="#更新长期记忆" class="headerlink" title="更新长期记忆"></a>更新长期记忆</h3><p>既然有了遗忘和更新机制，那么最终的长期记忆也就可以确定了。在$t$时刻：</p><p>$$ lsm_t = olsm_t + nlsm_t $$</p><p>上述公式还可以表示成：<br>$$ C_t = f_t \odot C_{t-1} + i_t \odot \tilde{C}_t $$</p><p>其中$\odot$表示element-wise product, 如果使用<code>*</code>替代，则能得到：<br>$$ C_t = f_t * C_{t-1} + i_t * \tilde{C}_t $$</p><p><img src="update_func.png" alt="update function"></p><h3 id="应用长期记忆"><a href="#应用长期记忆" class="headerlink" title="应用长期记忆"></a>应用长期记忆</h3><p>长期记忆需要应用在当前的工作记忆中才有作用。</p><h4 id="选择函数-1"><a href="#选择函数-1" class="headerlink" title="选择函数"></a>选择函数</h4><p>从上一个工作记忆和当前输入中确定选择函数。在$t$时刻：</p><p>$$ focus_t = \sigma (W_f x_t + U_f wm_{t-1}) $$</p><p>上述公式还可以表示成：<br>$$ o_t = \sigma (W_o \cdot [h_{t-1},x_t] + b_o) $$</p><h4 id="候选的工作记忆"><a href="#候选的工作记忆" class="headerlink" title="候选的工作记忆"></a>候选的工作记忆</h4><p>工作记忆是从长期记忆转换来的。在$t$时刻：</p><p>$$ wm’_t = \phi (lsm_{t-1}) $$</p><p>其中这里的$\phi$常常选择$tanh$</p><p>上述公式还可以表示成：</p><p>$$ \tilde{h}_t = \phi (C_t) $$</p><h4 id="更新工作记忆"><a href="#更新工作记忆" class="headerlink" title="更新工作记忆"></a>更新工作记忆</h4><p>既然有了候选工作记忆和选择函数，那么最终的工作记忆也就确定了。在$t$时刻：</p><p>$$ wm_t = focus_t \odot wm’_t $$</p><p>上述公式还可以表示成：</p><p>$$ h_t = o_t * \tilde{h}_t $$</p><p><img src="gen_func.png" alt="generate function"></p><h2 id="变种"><a href="#变种" class="headerlink" title="变种"></a>变种</h2><p>LSTM诞生后，不断有人改进模型，至今LSTM已经有很多变种了(请参考[参考文献]部分)。本节将介绍其中最重要的两个变种：Peephole LSTM和Gated Recurrent Unit</p><h3 id="Peephole-LSTM"><a href="#Peephole-LSTM" class="headerlink" title="Peephole LSTM"></a>Peephole LSTM</h3><p>普通的LSTM的所有的门的决策全部都是由输入$x$和$wm_{t-1}$决定，Peephole LSTM改进了门的实现，让$lsm_{t-1}$也参与门的决策。</p><p><img src="peephole_lstm.png" alt="peephole lstm"></p><h3 id="Coupled-Input-and-Forget-Gate-CIFG"><a href="#Coupled-Input-and-Forget-Gate-CIFG" class="headerlink" title="Coupled Input and Forget Gate (CIFG)"></a>Coupled Input and Forget Gate (CIFG)</h3><p>既然<code>forget gate</code>和<code>input gate</code>都是控制更新long-term memory（$C$）的，那么他们可以合并成为一个<code>update gate</code>:<code>forget gate</code>忘记的信息全部由<code>input gate</code>提供。</p><p><img src="CIFG_lstm.png" alt="CIFG lstm"></p><h3 id="Gated-Recurrent-Unit-GRU"><a href="#Gated-Recurrent-Unit-GRU" class="headerlink" title="Gated Recurrent Unit (GRU)"></a>Gated Recurrent Unit (GRU)</h3><p>GRU不仅使用了<code>update gate</code>替代了<code>forget gate</code>和<code>input gate</code>,而且将long-term memory ($C$)和working memory（$h$）合并了，并做了一些细微的调整。由于简化了原有LSTM的结构，速度更快，目前流行度不断增加。</p><p><img src="GRU_lstm.png" alt="GRU lstm"></p><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><ul><li><a href="http://colah.github.io/posts/2015-08-Understanding-LSTMs/" target="_blank" rel="noopener">Understanding LSTM Networks</a></li><li><a href="http://blog.echen.me/2017/05/30/exploring-lstms/" target="_blank" rel="noopener">Exploring LSTMs</a></li><li><a href="http://slazebni.cs.illinois.edu/spring17/lec03_rnn.pdf" target="_blank" rel="noopener">http://slazebni.cs.illinois.edu/spring17/lec03_rnn.pdf</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;TL:DR&lt;/strong&gt; 本文属于入门级课程101，用图文并茂的方式详细的介绍了LSTM的工作原理。&lt;br&gt;
    
    </summary>
    
      <category term="神经网络" scheme="https://blog.xiaoquankong.ai/categories/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="LSTM" scheme="https://blog.xiaoquankong.ai/tags/LSTM/"/>
    
      <category term="神经网络" scheme="https://blog.xiaoquankong.ai/tags/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>机器学习相关的理论资料汇总</title>
    <link href="https://blog.xiaoquankong.ai/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%9B%B8%E5%85%B3%E7%9A%84%E7%90%86%E8%AE%BA%E8%B5%84%E6%96%99%E6%B1%87%E6%80%BB/"/>
    <id>https://blog.xiaoquankong.ai/机器学习相关的理论资料汇总/</id>
    <published>2017-11-13T03:53:40.000Z</published>
    <updated>2018-08-13T11:08:02.500Z</updated>
    
    <content type="html"><![CDATA[<p><strong>TL;DR</strong> 本文章收集了一些机器学习相关的理论方面的入门级的资料，适合初学者作为入门课程101。<br><a id="more"></a></p><h1 id="数学基础"><a href="#数学基础" class="headerlink" title="数学基础"></a>数学基础</h1><h2 id="线性代数"><a href="#线性代数" class="headerlink" title="线性代数"></a>线性代数</h2><ul><li><a href="http://cs231n.stanford.edu/vecDerivs.pdf" target="_blank" rel="noopener">Vector, Matrix, and Tensor Derivatives</a> <strong>CS321n</strong> 介绍矩阵和向量导数的算法</li><li><a href="https://web.stanford.edu/~jduchi/projects/matrix_prop.pdf" target="_blank" rel="noopener">Properties of the Trace and Matrix Derivatives</a></li><li><a href="https://atmos.washington.edu/~dennis/MatrixCalculus.pdf" target="_blank" rel="noopener">Matrix Differentiation ( and some other stuff )</a> <strong>排版非常好看</strong></li></ul><h1 id="神经网络"><a href="#神经网络" class="headerlink" title="神经网络"></a>神经网络</h1><h2 id="Backpropagation"><a href="#Backpropagation" class="headerlink" title="Backpropagation"></a>Backpropagation</h2><ul><li><a href="http://colah.github.io/posts/2015-08-Backprop/" target="_blank" rel="noopener">Calculus on Computational Graphs: Backpropagation</a> <strong>推荐入门</strong> 从计算图的角度介绍BP算法</li></ul><h2 id="LSTM"><a href="#LSTM" class="headerlink" title="LSTM"></a>LSTM</h2><h3 id="博文"><a href="#博文" class="headerlink" title="博文"></a>博文</h3><ul><li><a href="http://blog.echen.me/2017/05/30/exploring-lstms/" target="_blank" rel="noopener">Exploring LSTMs</a> <strong>入门推荐</strong> 非常详细的用易于理解的方式介绍了LSTM中各种门，后面更大篇幅探索了一下LSTM在各种简单问题上的内部参数情况，但后面的部分，我暂时没看懂:(</li><li><a href="http://colah.github.io/posts/2015-08-Understanding-LSTMs/" target="_blank" rel="noopener">Understanding LSTM Networks</a> <strong>Stanford CS224n 推荐阅读</strong> 非常细致的介绍了LSTM中的各种门，建议先阅读上一篇文章再看这个文章，在理解为什么需要各种门的基础上再学习各种门是怎么实现的会更加清晰来龙去脉。</li></ul><h3 id="MOOC"><a href="#MOOC" class="headerlink" title="MOOC"></a>MOOC</h3><p><strong>TODO</strong></p><h3 id="大学课程"><a href="#大学课程" class="headerlink" title="大学课程"></a>大学课程</h3><ul><li><a href="http://web.stanford.edu/class/cs224n/" target="_blank" rel="noopener">Stanford CS224n: Natural Language Processing with Deep Learning</a> 没啥好介绍的，来自Stanford NLP group的，质量什么的没得说。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;TL;DR&lt;/strong&gt; 本文章收集了一些机器学习相关的理论方面的入门级的资料，适合初学者作为入门课程101。&lt;br&gt;
    
    </summary>
    
      <category term="机器学习" scheme="https://blog.xiaoquankong.ai/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="机器学习" scheme="https://blog.xiaoquankong.ai/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="资料汇总" scheme="https://blog.xiaoquankong.ai/tags/%E8%B5%84%E6%96%99%E6%B1%87%E6%80%BB/"/>
    
  </entry>
  
  <entry>
    <title>神经网络里的激活函数</title>
    <link href="https://blog.xiaoquankong.ai/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E9%87%8C%E7%9A%84%E6%BF%80%E6%B4%BB%E5%87%BD%E6%95%B0/"/>
    <id>https://blog.xiaoquankong.ai/神经网络里的激活函数/</id>
    <published>2017-11-09T15:31:52.000Z</published>
    <updated>2018-08-13T11:08:02.511Z</updated>
    
    <content type="html"><![CDATA[<p><strong>TL;DR</strong> 本文将介绍神经网络中常用的几种激活函数的特性和使用场合。<br><a id="more"></a></p><p>神经网络(Neural Network)中的激活函数(Activation Function)选择是至关重要的，它直接影响着模型的performance。</p><h2 id="各种激活函数介绍"><a href="#各种激活函数介绍" class="headerlink" title="各种激活函数介绍"></a>各种激活函数介绍</h2><p>下面将对比较常见的几种激活函数做简单的介绍：</p><h3 id="Sigmoid"><a href="#Sigmoid" class="headerlink" title="Sigmoid"></a>Sigmoid</h3><p>Sigmoid是最早被使用的激活函数之一，现在依旧经常出现在教科书和教学中，是最经典的激活函数之一。Sigmoid函数有时使用符号$\sigma$来表示。</p><h4 id="数学表示"><a href="#数学表示" class="headerlink" title="数学表示"></a>数学表示</h4><p>$$ a=\frac{1}{1+e^{-z}} $$</p><h4 id="图像"><a href="#图像" class="headerlink" title="图像"></a>图像</h4><p><img src="sigmoid.png" alt="graph of sigmoid function"><br>Note: 为了图像更加紧凑，这幅图实际对应的函数是$a=\frac{1}{1+e^{-5z}}$</p><h4 id="导数"><a href="#导数" class="headerlink" title="导数"></a>导数</h4><p>$$ f’(z)=\frac{\mathrm d \sigma}{\mathrm d z}=\frac{1}{1+e^{-z}}(1-\frac{1}{1+e^{-z}})=f(z)(1-f(z))=\sigma(1-\sigma) $$</p><h4 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h4><p>可以看到<code>sigmoid</code>函数的一个最大的特点就是：值域严格限制在<code>(0, 1)</code>开区间。这种特性使得<code>sigmoid</code>可以将实数范围的值表示成概率的形式，这是<code>sigmoid</code>最大的特点。</p><h3 id="tanh"><a href="#tanh" class="headerlink" title="tanh"></a>tanh</h3><p>tanh函数的全称是”hyperbolic tangent”,属于”Hyperbolic function”(双曲线函数)，关于这个函数的更多详细的资料可以访问Hyperbolic function在Wikipedia的<a href="https://en.wikipedia.org/wiki/Hyperbolic_function" target="_blank" rel="noopener">相关页面</a></p><h4 id="数学表示-1"><a href="#数学表示-1" class="headerlink" title="数学表示"></a>数学表示</h4><p>$$ a=\frac{e^{z}-e^{-z}}{e^{z}+e^{-z}} $$</p><h4 id="图像-1"><a href="#图像-1" class="headerlink" title="图像"></a>图像</h4><p><img src="tanh.png" alt="graph of tanh function"></p><h4 id="导数-1"><a href="#导数-1" class="headerlink" title="导数"></a>导数</h4><p>$$ f’(z)=\frac{\mathrm d \tanh}{\mathrm d z}=1-(\frac{e^{z}-e^{-z}}{e^{z}+e^{-z}})^2=1-f(z)^2=1-\tanh^2 $$</p><h4 id="特性-1"><a href="#特性-1" class="headerlink" title="特性"></a>特性</h4><p>tanh函数和sigmoid函数非常相似，都是一个优雅的S型曲线，事实上$tanh=sigmoid(z)*2+1$。唯一不同的地方是tanh的值域严格限制在<code>(-1, 1)</code>开区间。</p><h3 id="ReLU"><a href="#ReLU" class="headerlink" title="ReLU"></a>ReLU</h3><p>ReLU的全称是”Rectified Linear Unit”（中文名应该翻译成“线性整流函数”或“修正线性单元”，但中文名几乎无人使用）。是目前神经网络中最主流的激活函数。</p><h4 id="数学表示-2"><a href="#数学表示-2" class="headerlink" title="数学表示"></a>数学表示</h4><p>$$ a=max(0, z) $$</p><h4 id="图像-2"><a href="#图像-2" class="headerlink" title="图像"></a>图像</h4><p><img src="relu.png" alt="graph of ReLU function"></p><h4 id="导数-2"><a href="#导数-2" class="headerlink" title="导数"></a>导数</h4><p>$$<br>f’(z) =<br>  \begin{cases}<br>    0  &amp; \quad \text{if } z &lt; 0\\<br>    1  &amp; \quad \text{if } z &gt; 0<br>  \end{cases}<br>$$</p><h4 id="特性-2"><a href="#特性-2" class="headerlink" title="特性"></a>特性</h4><p>ReLU可以被看作是<code>sigmoid</code>函数在$(-\infty, 0)$定义域上的近似函数。如下图：<br><img src="relu_sigmoid.png" alt="graph of ReLU and sigmoid function"><br>上图中，蓝色的线表示sigmoid函数，绿色的线表示ReLU函数。<br>Note：为了让图更加容易理解，实际使用的sigmoid函数是$a=\frac{1}{1+e^{-5z}}$，ReLU函数是$a=max(0, z+0.5)$</p><p>同时因为因为数学上特别简单，所以计算速度非常快。已经在很多领域替代<code>sigmoid</code>和<code>tanh</code>。</p><h3 id="Leaky-ReLU"><a href="#Leaky-ReLU" class="headerlink" title="Leaky ReLU"></a>Leaky ReLU</h3><p>是对ReLU的微小改动，在某些情况下会有比较好的效果。</p><h4 id="数学表示-3"><a href="#数学表示-3" class="headerlink" title="数学表示"></a>数学表示</h4><p>$$ a=max(\alpha z, z) $$<br>其中$\alpha &lt; 1$</p><h4 id="图像-3"><a href="#图像-3" class="headerlink" title="图像"></a>图像</h4><p><img src="leaky_relu.png" alt="graph of leaky ReLU function"><br>Note: 上图中使用的函数为：$ a=max(0.05z, z) $</p><h4 id="导数-3"><a href="#导数-3" class="headerlink" title="导数"></a>导数</h4><p>$$<br>f’(z) =<br>  \begin{cases}<br>    \alpha  &amp; \quad \text{if } z &lt; 0\\<br>    1  &amp; \quad \text{if } z &gt; 0<br>  \end{cases}<br>$$</p><h4 id="特性-3"><a href="#特性-3" class="headerlink" title="特性"></a>特性</h4><p>Leaky ReLU是ReLU的改动版，在某些特定的情况下会有比较好的结果。</p><h2 id="列表对比"><a href="#列表对比" class="headerlink" title="列表对比"></a>列表对比</h2><p>下面用列表的形式，对常见的几种激活函数的特性和使用场景做一个总结：</p><table><thead><tr><th>函数名</th><th>函数公式</th><th>使用场景^[来自：<a href="https://www.coursera.org/learn/neural-networks-deep-learning/lecture/4dDC1/activation-functions" target="_blank" rel="noopener">Neural Networks and Deep Learning by Andrew Ng on Coursera</a>]</th></tr></thead><tbody><tr><td>sigmoid</td><td>$a=\frac{1}{1+e^{-z}}$</td><td>适合二分类问题的output layer</td></tr><tr><td>tanh</td><td>$a=\frac{e^{z}-e^{-z}}{e^{z}+e^{-z}}$</td><td>绝大多数情况下优于sigmoid</td></tr><tr><td>ReLU</td><td>$a=max(0, z)$</td><td>优先使用这种方法（推荐）</td></tr><tr><td>Leaky ReLU</td><td>$a=max(\alpha z, z)$</td><td>某些情况下效果较好</td></tr></tbody></table><p>Note: 在实际场景中，可以尝试不同的函数，寻找最优方案。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;TL;DR&lt;/strong&gt; 本文将介绍神经网络中常用的几种激活函数的特性和使用场合。&lt;br&gt;
    
    </summary>
    
      <category term="机器学习" scheme="https://blog.xiaoquankong.ai/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="神经网络" scheme="https://blog.xiaoquankong.ai/tags/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/"/>
    
      <category term="激活函数" scheme="https://blog.xiaoquankong.ai/tags/%E6%BF%80%E6%B4%BB%E5%87%BD%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>python中requirements.txt的编码问题</title>
    <link href="https://blog.xiaoquankong.ai/python%E4%B8%ADrequirements.txt%E7%9A%84%E7%BC%96%E7%A0%81%E9%97%AE%E9%A2%98/"/>
    <id>https://blog.xiaoquankong.ai/python中requirements.txt的编码问题/</id>
    <published>2017-11-09T09:10:26.000Z</published>
    <updated>2018-08-13T11:08:02.495Z</updated>
    
    <content type="html"><![CDATA[<p><strong>TL;DR</strong> requirements.txt中不要使用非ASCII编码的字符，否则会造成字符集错误，无法解析内容</p><a id="more"></a><h2 id="实验设计"><a href="#实验设计" class="headerlink" title="实验设计"></a>实验设计</h2><ol><li>两份requirements.txt文件，包含相同的依赖，但不同的地方是：一份是ASCII编码（或者说只包含英文字符）；另一份包含非ASCII字符（比如中文注释之类的）</li><li>分别安装两份requirements.txt文件，观察现象</li></ol><h2 id="实验材料"><a href="#实验材料" class="headerlink" title="实验材料"></a>实验材料</h2><h3 id="ASCII编码的requirements-txt"><a href="#ASCII编码的requirements-txt" class="headerlink" title="ASCII编码的requirements.txt"></a>ASCII编码的requirements.txt</h3><p>命名为：<code>all_ascii_requirements.txt</code></p><p>具体内容如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dummy</span><br></pre></td></tr></table></figure><h3 id="非ASCII编码的requirements-txt"><a href="#非ASCII编码的requirements-txt" class="headerlink" title="非ASCII编码的requirements.txt"></a>非ASCII编码的requirements.txt</h3><p>命名为：<code>non_ascii_requirements.txt</code></p><p>具体内容如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 这个是中文注释</span><br><span class="line">dummy</span><br></pre></td></tr></table></figure></p><h2 id="实验过程"><a href="#实验过程" class="headerlink" title="实验过程"></a>实验过程</h2><h3 id="安装ASCII编码的requirements-txt"><a href="#安装ASCII编码的requirements-txt" class="headerlink" title="安装ASCII编码的requirements.txt"></a>安装ASCII编码的requirements.txt</h3><p>执行命令 <code>pip install -r all_ascii_requirements.txt</code></p><p>命令工作正常，输入内容如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Collecting dummy (from -r all_ascii_requirements.txt (line 1))</span><br><span class="line">  Downloading dummy-0.1.0.zip</span><br><span class="line">Requirement already up-to-date: jinja2&gt;=2.0.0 in /usr/local/lib/python2.7/dist-packages (from dummy-&gt;-r all_ascii_requirements.txt (line 1))</span><br><span class="line">Collecting numpy&gt;=1.0.0 (from dummy-&gt;-r all_ascii_requirements.txt (line 1))</span><br><span class="line">  Downloading numpy-1.13.1-cp27-cp27mu-manylinux1_x86_64.whl (16.6MB)</span><br><span class="line">    100% |################################| 16.6MB 66kB/s </span><br><span class="line">Requirement already up-to-date: mock&gt;=1.0.0 in /usr/local/lib/python2.7/dist-packages (from dummy-&gt;-r all_ascii_requirements.txt (line 1))</span><br><span class="line">Requirement already up-to-date: MarkupSafe&gt;=0.23 in /usr/local/lib/python2.7/dist-packages (from jinja2&gt;=2.0.0-&gt;dummy-&gt;-r all_ascii_requirements.txt (line 1))</span><br><span class="line">Requirement already up-to-date: six&gt;=1.9 in /usr/local/lib/python2.7/dist-packages (from mock&gt;=1.0.0-&gt;dummy-&gt;-r all_ascii_requirements.txt (line 1))</span><br><span class="line">Requirement already up-to-date: funcsigs&gt;=1; python_version &lt; &quot;3.3&quot; in /usr/local/lib/python2.7/dist-packages (from mock&gt;=1.0.0-&gt;dummy-&gt;-r all_ascii_requirements.txt (line 1))</span><br><span class="line">Requirement already up-to-date: pbr&gt;=0.11 in /usr/local/lib/python2.7/dist-packages (from mock&gt;=1.0.0-&gt;dummy-&gt;-r all_ascii_requirements.txt (line 1))</span><br><span class="line">Building wheels for collected packages: dummy</span><br><span class="line">  Running setup.py bdist_wheel for dummy ... done</span><br><span class="line">  Stored in directory: /root/.cache/pip/wheels/fb/72/de/c12e171be0c7bff52d4bcebf680bd3b012203c68b8372b02a5</span><br><span class="line">Successfully built dummy</span><br><span class="line">Installing collected packages: numpy, dummy</span><br><span class="line">  Found existing installation: numpy 1.11.0</span><br><span class="line">    Uninstalling numpy-1.11.0:</span><br><span class="line">      Successfully uninstalled numpy-1.11.0</span><br><span class="line">Successfully installed dummy-0.1.0 numpy-1.13.1</span><br></pre></td></tr></table></figure><h3 id="安装非ASCII编码的requirements-txt"><a href="#安装非ASCII编码的requirements-txt" class="headerlink" title="安装非ASCII编码的requirements.txt"></a>安装非ASCII编码的requirements.txt</h3><p>执行命令 <code>pip install -r non_ascii_requirements.txt</code></p><p>命令工作出现异常，输出内容如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Exception:</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;/usr/local/lib/python2.7/dist-packages/pip/basecommand.py&quot;, line 215, in main</span><br><span class="line">    status = self.run(options, args)</span><br><span class="line">  File &quot;/usr/local/lib/python2.7/dist-packages/pip/commands/install.py&quot;, line 312, in run</span><br><span class="line">    wheel_cache</span><br><span class="line">  File &quot;/usr/local/lib/python2.7/dist-packages/pip/basecommand.py&quot;, line 295, in populate_requirement_set</span><br><span class="line">    wheel_cache=wheel_cache):</span><br><span class="line">  File &quot;/usr/local/lib/python2.7/dist-packages/pip/req/req_file.py&quot;, line 84, in parse_requirements</span><br><span class="line">    filename, comes_from=comes_from, session=session</span><br><span class="line">  File &quot;/usr/local/lib/python2.7/dist-packages/pip/download.py&quot;, line 422, in get_file_content</span><br><span class="line">    content = auto_decode(f.read())</span><br><span class="line">  File &quot;/usr/local/lib/python2.7/dist-packages/pip/utils/encoding.py&quot;, line 31, in auto_decode</span><br><span class="line">    return data.decode(locale.getpreferredencoding(False))</span><br><span class="line">UnicodeDecodeError: &apos;ascii&apos; codec can&apos;t decode byte 0xe8 in position 2: ordinal not in range(128)</span><br></pre></td></tr></table></figure><h2 id="实验结论"><a href="#实验结论" class="headerlink" title="实验结论"></a>实验结论</h2><p>pip在解析requirements.txt，只能处理ASCII编码的文件，否则会出现Unicode错误。在编写requirements.txt时，切记使用ASCII编码，不要夹杂中文等非ASCII字符</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;TL;DR&lt;/strong&gt; requirements.txt中不要使用非ASCII编码的字符，否则会造成字符集错误，无法解析内容&lt;/p&gt;
    
    </summary>
    
    
      <category term="Python" scheme="https://blog.xiaoquankong.ai/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>使用chatterbot构建自己的中文chat(闲聊)机器人</title>
    <link href="https://blog.xiaoquankong.ai/%E4%BD%BF%E7%94%A8chatterbot%E6%9E%84%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E4%B8%AD%E6%96%87chat(%E9%97%B2%E8%81%8A)%E6%9C%BA%E5%99%A8%E4%BA%BA/"/>
    <id>https://blog.xiaoquankong.ai/使用chatterbot构建自己的中文chat(闲聊)机器人/</id>
    <published>2017-11-09T07:05:54.000Z</published>
    <updated>2018-08-13T11:08:02.496Z</updated>
    
    <content type="html"><![CDATA[<p><strong>TL;DR</strong> 本文使用开源框架chatterbot从零开始构建你自己的聊天机器人（还带有WEB界面奥～）。<a id="more"></a></p><p>聊天机器人大体上分为三种：闲聊机器人、问答机器人和任务型机器人。闲聊机器人，顾名思义就是和你闲聊插科打诨的机器人，目前比较典型的代表是微软小冰，小黄鸡等。问答机器人有一个标准答案库，当用户来咨询时机器人负责理解用户的语意，给出符合语意的标准答案，目前比较典型的应用是各类咨询机器人，客服机器人等。最后一类：任务型机器人，通过和客户的沟通帮助用户完成特定任务比如定机票、定闹钟等，目前比较典型的应用是各种私人助理，苹果的siri系统也具备此类功能。</p><p>我们这里介绍一个简单易用的闲聊机器人框架chatterbot website: <a href="http://chatterbot.readthedocs.io/" target="_blank" rel="noopener">http://chatterbot.readthedocs.io/</a></p><p>先上一个成品图，这将是我们最后完成时的效果：</p><p><img src="Chat_Instance-1024x736.png" alt="Chat Instance"></p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install chatterbot</span><br></pre></td></tr></table></figure><h2 id="快速入门（toy级别的方案）"><a href="#快速入门（toy级别的方案）" class="headerlink" title="快速入门（toy级别的方案）"></a>快速入门（toy级别的方案）</h2><p>下面的代码实现了一个toy聊天机器人</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"># 导入所需的依赖</span><br><span class="line">from chatterbot import ChatBot</span><br><span class="line">from chatterbot.trainers import ListTrainer</span><br><span class="line"></span><br><span class="line">chatbot = ChatBot(&quot;SillyRobot&quot;)  # 这里创建了机器人实例，并设定了机器人的名字：SillyRobot</span><br><span class="line"></span><br><span class="line"># 定义训练数据集</span><br><span class="line">conversation = [</span><br><span class="line">    &quot;Hello&quot;,</span><br><span class="line">    &quot;Hi there!&quot;,</span><br><span class="line">    &quot;How are you doing?&quot;,</span><br><span class="line">    &quot;I&apos;m doing great.&quot;,</span><br><span class="line">    &quot;That is good to hear&quot;,</span><br><span class="line">    &quot;Thank you.&quot;,</span><br><span class="line">    &quot;You&apos;re welcome.&quot;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"># 训练</span><br><span class="line">chatbot.set_trainer(ListTrainer)</span><br><span class="line">chatbot.train(conversation)</span><br><span class="line"></span><br><span class="line"># 响应用户请求</span><br><span class="line">response = chatbot.get_response(&quot;Good morning!&quot;)</span><br><span class="line">print(response)</span><br></pre></td></tr></table></figure><p>上述代码会训练你给定的训练集，并把训练结果保存起来，没有指定的情况下，会使用存储模块<code>chatterbot.storage.SQLStorageAdapter</code>完成模型的存储。在完成训练后就可以将训练代码移除，这样机器人就不会每次都要从头训练了。</p><h2 id="比较正式的方案"><a href="#比较正式的方案" class="headerlink" title="比较正式的方案"></a>比较正式的方案</h2><p>上面的方案使用的语料库是硬编码在文档中的，这在正式项目中是不合适的。下面介绍一个比较正式的使用chatter的方案。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">import os</span><br><span class="line"></span><br><span class="line">from chatterbot import ChatBot</span><br><span class="line">from chatterbot.trainers import ChatterBotCorpusTrainer</span><br><span class="line"></span><br><span class="line">current_dir = os.path.dirname(os.path.realpath(__file__))</span><br><span class="line"></span><br><span class="line">chat_bot = ChatBot(&quot;SillyRobot&quot;) # 这里创建了机器人实例，并设定了机器人的名字：SillyRobot</span><br><span class="line">chat_bot.set_trainer(ChatterBotCorpusTrainer)</span><br><span class="line"># 使用中文语料库训练它</span><br><span class="line"># chat_bot.train(&quot;chatterbot.corpus.chinese&quot;)  # 语料库</span><br><span class="line"># 开始对话</span><br><span class="line">response = chat_bot.get_response(&quot;我好么&quot;)</span><br><span class="line">print(response)</span><br></pre></td></tr></table></figure><p>官方自带的中文聊天数据集表现比较差，你需要自己实现一个<code>trainer</code>，具体怎么实现见官方文档 <a href="http://chatterbot.readthedocs.io/en/stable/training.html#creating-a-new-training-class" target="_blank" rel="noopener">Creating a new training class</a>.</p><h2 id="Web集成"><a href="#Web集成" class="headerlink" title="Web集成"></a>Web集成</h2><p>chatter自带了Django集成，所以很容易架设一个网站，提供HTTP接口、管理后台以及在线聊天页面等功能。具体代码可以拷贝官方的示例代码<a href="https://github.com/gunthercox/ChatterBot/tree/master/examples/django_app" target="_blank" rel="noopener">https://github.com/gunthercox/ChatterBot/tree/master/examples/django_app</a>, 这里需要注意的是，你需要更改chatterbot的配置在<code>settings.py</code>里面的<code>CHATTERBOT</code>变量处，具体怎么修改，请参考<a href="http://chatterbot.readthedocs.io/en/stable/django/settings.html#chatterbot-django-settings" target="_blank" rel="noopener">文档1</a>和<a href="http://chatterbot.readthedocs.io/en/stable/django/training.html#training-settings" target="_blank" rel="noopener">文档2</a>,但你仍然需要以下步骤：</p><h3 id="安装Django"><a href="#安装Django" class="headerlink" title="安装Django"></a>安装Django</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install django</span><br></pre></td></tr></table></figure><h3 id="同步数据库"><a href="#同步数据库" class="headerlink" title="同步数据库"></a>同步数据库</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python manage.py migrate</span><br></pre></td></tr></table></figure><h3 id="创建超级用户"><a href="#创建超级用户" class="headerlink" title="创建超级用户"></a>创建超级用户</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python manage.py createsuperuser</span><br></pre></td></tr></table></figure><h3 id="训练chatterbot"><a href="#训练chatterbot" class="headerlink" title="训练chatterbot"></a>训练chatterbot</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python manage.py train</span><br></pre></td></tr></table></figure><h3 id="运行server"><a href="#运行server" class="headerlink" title="运行server"></a>运行server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python manage.py runserver</span><br></pre></td></tr></table></figure><p>web服务器默认监听5000端口，访问<a href="http://127.0.0.0.1:5000" target="_blank" rel="noopener">http://127.0.0.0.1:5000</a>就能访问页面了，页面效果如下图：</p><p><img src="Django_ChatterBot_Example-1024x561.png" alt="Django ChatterBot Example"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;TL;DR&lt;/strong&gt; 本文使用开源框架chatterbot从零开始构建你自己的聊天机器人（还带有WEB界面奥～）。
    
    </summary>
    
    
      <category term="NLU" scheme="https://blog.xiaoquankong.ai/tags/NLU/"/>
    
  </entry>
  
  <entry>
    <title>再见wordpress,你好hexo</title>
    <link href="https://blog.xiaoquankong.ai/%E5%86%8D%E8%A7%81wordpress,%E4%BD%A0%E5%A5%BDhexo/"/>
    <id>https://blog.xiaoquankong.ai/再见wordpress,你好hexo/</id>
    <published>2017-11-08T12:40:00.000Z</published>
    <updated>2018-08-13T11:08:02.499Z</updated>
    
    <content type="html"><![CDATA[<p><strong>TL;DR</strong> 弃坑wordpress，走向hexo<br><a id="more"></a><br>一直以来，我都是使用wordpress来写博客，从Octopress时代就想尝试静态博客系统的，但由于惰性使然，一直也就用着wordpress。<br>最近两个事情让我终于下定决心要切换博客系统了：一是wordpress的markdown支持实在太烂，用了不少相关插件但是还是不好用；二是wordpress里面没有一个让我称心如意的主题,hexo的Next主题确实很适合码农，我在wordpress世界里找不到类似的主题。所以，还是选择追随潮流，很多技术人都选择了hexo，我想应该是有保障的,又开始折腾之路。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;TL;DR&lt;/strong&gt; 弃坑wordpress，走向hexo&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
</feed>
